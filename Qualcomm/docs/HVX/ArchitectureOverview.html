<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style type="text/css">
table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}
td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}

.smarkdoc {
  margin-left: 42px; margin-right: 42px;
  font-size: 13px;
  font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif;
}

h1, h2, h3 { color: #3c4c6c; }
h1 {
  text-align: center;
  font-size: 200%;
/*    margin-left: -30px; */
  clear: both;
}
h2 {
  font-size: 160%;
  margin: 32px -40px 24px -42px;
  padding: 3px 24px 8px;
  border-bottom: 2px solid #5088c5;
  clear: both;
}
h3 {
  font-size: 130%;
  margin: 20px -4px 10px;
  padding: 4px;
  clear: both;
}
h4 {
  font-size: 110%;
  margin: 2em 0 1em;
}

pre {
  font-size: 90%;
  background-color: #f0f0f4; padding: 6px; border: 1px solid #d0d0ee;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

.pre {
  font-size: 90%;
  padding: 6px;
  background-color: #f0f0f4;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

code {
  font-size: 90%;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

h3 code {
  font-size: 100%;
}

p {
  margin: 0.8em 0;
}
ul, ol {
  margin: 1em 0 1em 3em; padding: 0;
}
div.indent {
  margin: 0 3em;
}

a[href] {
  text-decoration: none;
  color: #2020b0;
}
a[href]:hover {
  border-bottom: 1px dotted #2030d0;
}

/* Smark Users Guide */

.codebox {
  padding: 0 1px;  margin-right:1px;
  border:1px solid #d0d0ee;
  background-color: #f0f0f4;
  font-weight: bold;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* .art .line {  -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.3); } */

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console";
   margin-left: auto; margin-right: auto;
   background-color: white;
   /* border: 1px solid #555; */  /* Useful for non-white pages */
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
.toc {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em;
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}

/* ================ Print ================ */

@media print {

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 3in 0 20px; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em -2em }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}

/* ================  Layout  ================ */
/*
 *  +------------------------+
 *  |         #header        |
 *  +----------+-------------+
 *  | #sidebar |  #content   |
 *  |          |             |
 *  +----------+-------------+
 *
 * CSS padding, border width, and border style (!) affect the actual height
 * (and in turn layout).
 */

#header {
  position: fixed;
  top: 0px;
  height: 32px;
  left: 0px;
  width: 100%;
  padding: 10px 10px 0 0;
}
#sidebar {
  position: fixed;
  top: 42px;
  bottom: 0px;
  left: 0px;
  min-width: 180px;
  overflow: auto;
  border: 1px solid transparent;
  border-width: 0 1px 0 1px;
  padding: 0px 5px 0px 5px;
}
#content {
  position: fixed;
  top: 60px;
  left: 200px;
  bottom: 0px;
  right: 0px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding: 10px 20px;
  padding-top: 0;
}

/* ================  Styles  ================ */


body {
  font-family: "Lucida Grande", Helvetica, Arial, sans-serif;
  font-size: 16px;
}

#header {
  color: #fff;
  background: #555;
  text-align: center;
  font-size: 25px;
}

#sidebar {
  color: #000;
  background: #eee;
  border-right: 1px solid #bbb;
  text-align: left;
  font-size: 12px;
  line-height: 50%;
}

#sidebar h1 {
  margin: 0 0 0 0;
  border-left: 5px solid transparent;
  text-align: left;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}

#sidebar h2 {
  margin: 2px 0 8px 0;
  border-left: 5px solid transparent;
  text-align: center;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}



#content {
  margin: 0;
  font-size: 13px;
  line-height: 160%;
}

#content h1, #content h2 {
  border-bottom: 2px solid;
  font-size: 1.8em;
  font-weight: normal;
  margin: 2.0em 0px 1.3em 0px;
  padding-bottom: 0.6em;
  text-align: left;
}

#content h3 {
  color: #242220;
  font-size: 1.4em;
  font-weight: normal;
  margin: 2em 0px 0.8em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}
#content h4 {
  font-size: 1.2em;
  font-weight: normal;
  margin: 2em 0px 0.5em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}

a[href] {
  color: #05c;
  text-decoration: none;
}

#sidebar a {
  /*text-shadow:  1px 1px 2px #fff, -1px -1px #ddd;*/
  line-height: 40%;
}

pre, code {
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
  font-family: "Monaco", monospace;  font-size: 90%;
  background-color: #f8f8fa;
  border: 1px solid #e4e4ee;
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  border-radius: 2px;
  padding: 1px 0 0 1px;
}

pre {
  padding: 2px 4px;
}

table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}

/* Highlight currently-selected sidebar link */

#sidebar a.thisfile {
  color: #557;
}

/* indentation */

#content {
   padding-left: 60px;
}
#content h1, 
#content h2, 
#content h3, h4 {
    margin-left: -30px;
}

h3 > code {
    font-size: 80%;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV 
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console"; 
   margin-left: auto; margin-right: auto;
   background-color: white;
   border: 1px solid #555;
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
/*
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
*/

.toc {
  column-count: 1; column-gap: 2em;
  -moz-column-count: 1; -moz-column-gap: 2em;
  -webkit-column-count: 1; -webkit-column-gap: 2em; 
   alternate: column-width: 235px; column-rule-width: 5px;
}


.columns {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em; p
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}


/* ================ Print ================ */

@media print {

  #header, #content { position: static; }
  #sidebar { display: none; }

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 1in 0 1in; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em 0 }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}


</style><style type="text/css">
.search { right: 20pt; position: fixed; top: 5pt }

</style><title>Hexagon Vector Extensions (HVX)</title>
</head><body>
<div class="smarkdoc"><div id="header">Hexagon SDK 3.4.3</div><div id="sidebar"><top><img src="../images/sidebar_top.jpg"></top><script src="../scripts/post.js" type="text/javascript"></script><form class="search" id="searchForm"><input id="searchquery" name="q" onkeydown="postFunctionKeydown(event, true)"><input id="searchButton" onclick="postFunction(true)" type="button" value="Search"></form><p>
<a href="../index.html">Quick start</a>
</p><hr>
<p>
<a href="../feature_matrix.html">Feature Matrix</a>
</p><hr>
<p>
<a href="../hexagon_architecture.html">Hexagon Architecture</a>
</p><hr>
<p>
<a href="../images/Hexagon_Document_Bundle.pdf#page=2881">Hexagon Compiler/Linker</a>
</p><hr>
<p>
<a href="../hexagon_libraries.html">Hexagon Standard Libraries</a>
</p><hr>
<p>
<a href="../images/80-VB419-178_QuRT_User_Guide.pdf">Hexagon RTOS</a>
</p><hr>
<p>
<a href="../images/80-VB419-108_Hexagon_DSP_User_Guide.pdf">Hexagon DSP Programming</a>
</p><hr>
<h3>
<a name="Platforms"></a>Platforms
</h3><p>
<a href="../Platforms_HLOS.html">HLOS</a>
</p><p>
<a href="../Platforms_Simulator.html">Simulator</a>
</p><p>
<a href="../Platforms_Target.html">Target</a>
</p><hr>
<h3>
<a name="Environments"></a>Environments
</h3><p>
<a href="../Environments_Build%20System.html">Build System</a>
</p><p>
<a href="../Environments_Build%20System%20Porting.html">Build System Porting</a>
</p><p>
<a href="../Environments_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="ArchitectureOverview"></a>ArchitectureOverview
</h3><p>
<a href="../HVX/ArchitectureOverview.html">HVX</a>
</p><hr>
<h3>
<a name="Applications"></a>Applications
</h3><p>
<a href="../Audio/Applications.html">Audio</a>
</p><p>
<a href="../Camera%20streaming/Applications.html">Camera streaming</a>
</p><p>
<a href="../Applications_Compute%20offload.html">Compute offload</a>
</p><p>
<a href="../FastCV/Applications_Computer%20Vision.html">Computer Vision</a>
</p><p>
<a href="../Neural%20Networks/Applications.html">Neural Networks</a>
</p><p>
<a href="../Voice/Applications.html">Voice</a>
</p><hr>
<h3>
<a name="APIs"></a>APIs
</h3><p>
<a href="../APIs_Async%20Message%20Queue.html">Async Message Queue</a>
</p><p>
<a href="../APIs_DSP%20Clk%20&amp;%20Rsrc%20Mgmt.html">DSP Clk &amp; Rsrc Mgmt</a>
</p><p>
<a href="../APIs_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="../APIs_FastRPC.html">FastRPC</a>
</p><hr>
<h3>
<a name="Examples"></a>Examples
</h3><p>
<a href="../Audio/Examples.html">Audio</a>
</p><p>
<a href="../Camera%20streaming/Examples.html">Camera streaming</a>
</p><p>
<a href="../Examples_Common.html">Common</a>
</p><p>
<a href="../Examples_ComputeHVX.html">ComputeHVX</a>
</p><p>
<a href="../Examples_GeneralOverview.html">GeneralOverview</a>
</p><p>
<a href="../Neural%20Networks/Examples.html">Neural Networks</a>
</p><hr>
<h3>
<a name="Testing"></a>Testing
</h3><p>
<a href="../CAPIv2/Testing_CAPIv2%20Unit%20Tests.html">CAPIv2 Unit Tests</a>
</p><p>
<a href="../Testing_Eclipse%20Unit%20Tests.html">Eclipse Unit Tests</a>
</p><hr>
<h3>
<a name="Debugging"></a>Debugging
</h3><p>
<a href="../Debugging_Connect%20to%20Device.html">Connect to Device</a>
</p><p>
<a href="../Debugging_Exceptions.html">Exceptions</a>
</p><p>
<a href="../Debugging_Message%20Logging.html">Message Logging</a>
</p><p>
<a href="../Debugging_Simulator.html">Simulator</a>
</p><p>
<a href="../Debugging_Target.html">Target</a>
</p><hr>
<h3>
<a name="Tools"></a>Tools
</h3><p>
<a href="../Tools_Hexagon%20Tools%208.3.html">Hexagon Tools 8.3</a>
</p><p>
<a href="../Tools_IDL%20Compiler.html">IDL Compiler</a>
</p><p>
<a href="../Tools_On%20Target%20Profiling.html">On Target Profiling</a>
</p><p>
<a href="../Tools_Scripts.html">Scripts</a>
</p><p>
<a href="../Tools_Signing.html">Signing</a>
</p><p>
<a href="../Tools_UserGuides.html">UserGuides</a>
</p><p>
<a href="../Tools_Utilities.html">Utilities</a>
</p><hr>
<h3>
<a name="FAQ"></a>FAQ
</h3><p>
<a href="../FAQ_Common.html">Common</a>
</p><p>
<a href="../FAQ_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="../FAQ_FastRPC.html">FastRPC</a>
</p><p>
<a href="../FAQ_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="Dependencies"></a>Dependencies
</h3><p>
<a href="../Dependencies_Common.html">Common</a>
</p><hr>
<h3>
<a name="Release%20Notes"></a>Release Notes
</h3><p>
<a href="../Release%20Notes_Common.html">Common</a>
</p><hr>
<h3>
<a name="Support"></a>Support
</h3><p>
<a href="../Support_Contact.html">Contact</a>
</p><center><img src="../images/sidebar_bot.jpg"></center></div><div id="content"><a name="_top_" style="display:block;"></a><h1>
<a name="Hexagon%20Vector%20Extensions%20(HVX)"></a>Hexagon Vector Extensions (HVX)
</h1><div class="toc"><div class="tocLevel"><a href="#Hexagon/HVX%20Overview">Hexagon/HVX Overview</a></div><div class="tocLevel"><a href="#Supported%20Hexagon/HVX%20Targets">Supported Hexagon/HVX Targets</a><div class="tocLevel"><a href="#SDM820/821%20(Hexagon%20v60)">SDM820/821 (Hexagon v60)</a><div class="tocLevel"><a href="#L2%20Cache">L2 Cache</a></div><div class="tocLevel"><a href="#aDSP%20Eviction">aDSP Eviction</a></div><div class="tocLevel"><a href="#HVX%20context%20management">HVX context management</a></div><div class="tocLevel"><a href="#Clocks%20Setup">Clocks Setup</a></div><div class="tocLevel"><a href="#SDM820/SDM821%20Hexagon/HVX%20Documents%20and%20Resources">SDM820/SDM821 Hexagon/HVX Documents and Resources</a></div></div><div class="tocLevel"><a href="#SDM835%20(Hexagon%20v62)">SDM835 (Hexagon v62)</a><div class="tocLevel"><a href="#SDM835%20Hexagon/HVX%20Documents%20and%20Resources">SDM835 Hexagon/HVX Documents and Resources</a></div></div><div class="tocLevel"><a href="#SDM660%20(Hexagon%20v60)">SDM660 (Hexagon v60)</a><div class="tocLevel"><a href="#Removal%20of%20audio/voice%20concurrency%20considerations">Removal of audio/voice concurrency considerations</a></div><div class="tocLevel"><a href="#HVX%20Context%20Management">HVX Context Management</a></div><div class="tocLevel"><a href="#_Clocks%20Setup">Clocks Setup</a></div><div class="tocLevel"><a href="#SDM660%20Hexagon/HVX%20Documents%20and%20Resources">SDM660 Hexagon/HVX Documents and Resources</a></div></div><div class="tocLevel"><a href="#SDM845/SDM670/SDM710%20(Hexagon%20v65)">SDM845/SDM670/SDM710 (Hexagon v65)</a><div class="tocLevel"><a href="#SDM845%20Hexagon/HVX%20Documents%20and%20Resources">SDM845 Hexagon/HVX Documents and Resources</a></div></div><div class="tocLevel"><a href="#SM8150%20(Hexagon%20v66)">SM8150 (Hexagon v66)</a><div class="tocLevel"><a href="#SM8150%20Hexagon/HVX%20Documents%20and%20Resources">SM8150 Hexagon/HVX Documents and Resources</a></div></div></div><div class="tocLevel"><a href="#Hexagon/HVX%20Libraries">Hexagon/HVX Libraries</a><div class="tocLevel"><a href="#Hexagon%20NN">Hexagon NN</a></div><div class="tocLevel"><a href="#FastCV">FastCV</a></div><div class="tocLevel"><a href="#qmath">qmath</a></div></div></div><h2>
<a name="Hexagon/HVX%20Overview"></a>Hexagon/HVX Overview
</h2><p>
Hexagon Vector eXtensions (HVX) is a wide-vector engine available on select products with Hexagon V60 and higher. It is especially useful for achieving low-power, high-performance imaging and machine learning algorithms. Below is a block diagram of the Hexagon v60/v62/v65 processor with its two HVX units.
</p><left><img alt="<Image not found&gt;" src="images/block_dgm.png"></left><p>
Below is a diagram of the Hexagon v66 processor present in SM8150. It is upgraded with four HVX units, and the now each cluster has dedicated scalar MAC &amp; FP units.
</p><left><img alt="<Image not found&gt;" src="images/v66_block_dgm.png"></left><p>
As shown in the diagrams, instruction packets flow through the scalar Hexagon pipeline, where any included scalar instructions are processed, after which any the packets continue on to HVX Vector FIFO. As such, HVX instructions can be intermixed with non-HVX (a.k.a. scalar) instructions, even within an instruction packet, in DSP applications.
</p><p>
In addition to wide-vector instructions, the HVX module also includes a proprietary <a href="../Camera%20streaming/Applications.html">camera streaming</a> interface that allows high-resolution raw camera sensor pixels to be streamed through the DSP for line-based processing prior to entering the camera front end. This architecture enables pixel manipulation and statistics collection on the full-sized sensor outputs without any additional external memory traffic.
</p><p>
Note that the HVX engine is directly connected to L2 cache, bypassing L1. HVX instructions are pipelined deeply enough to avoid any observed latencies for L2 loads or stores (when the pipeline is full and L2 traffic is not too congested). However, due to the depth of the HVX pipeline, it is expensive to do a transfer from an HVX register to a scalar register, or to perform a scalar memory load from an address following an HVX store to the same cache line. It is advisable when using HVX in performance-sensitive code, to do all loads, stores, and arithmetic via HVX instructions, and to use scalar instructions and registers only for addressing, control, and/or processing on a different data set than that being done in HVX.
</p><p>
HVX was introduced in the SDM820/SDM821 family (a.k.a. MSM8996/MSM8996 PRO) in the Hexagon v60 aDSP (Applications DSP). SDM835 (a.k.a. MSM8998) followed the same architecture, with an upgrade to the Hexagon v62 for the aDSP. Starting in SDM660, HVX has moved to the new Compute DSP (cDSP) in order to separate it from audio and voice processing that remains on the aDSP. In SDM660, the cDSP is a Hexagon v60. In SDM845, the cDSP is the Hexagon v65, which introduces an internal memory (Vector TCM) and a new scatter/gather mechanism. For details, see - document 80-P8754-31 Hexagon CDSP HVX Overview for SDM660 (available in CreatePoint). The cDSP subsystem in SDM845 also includes a UBWC/DMA engine and a Hexagon Co-processor (HCP) block, which includes some video post-processing functions. UBWC/DMA and HCP are both controlled from cDSP software. More information on the UBWC/DMA engine and the HCP block will be available in the next release of the Hexagon SDK. In SM8150, there are 4 128B HVX units, and 64B mode is no longer supported.
</p><p>
Access to the Hexagon with HVX for compute applications is enabled via <a href="../APIs_FastRPC.html">FastRPC</a>. Within the Hexagon code, there has been an evolution in the SW frameworks that manage FastRPC, HVX contexts and mode, core and bus clocks, and RTOS features such as multi-threading. The sections below explain this evolution throughout the targets supported by this SDK revision. This evolution has been managed such that applications written originally for one target should still work reasonably without any code changes on later targets, though the recommendations for best practices have changed with each target. This table summarizes the key differences between supported targets, which are listed in chronological order.
</p><table><tr><th colspan="3"><p>
Target | Hexagon | DSP with HVX
</p><div class="indent"><p>
| Version |
</p></div></th><th><p>
Key differences
</p></th></tr><tr><td><p>
SDM820/ SDM821
</p></td><td><p>
v60
</p></td><td><p>
aDSP (shared with audio)
</p></td><td><p>
First DSP with HVX and Camera Streaming support.
</p><p>
Recommended dspCV_concurrency_query() lookup/eviction to
</p><p>
protect audio.
</p><p>
512 KB L2 cache partitioned 50%/50% during audio/compute
</p><p>
concurrency.
</p><p>
Recommended calling dspCV_init_with_attributes()
</p><p>
remotely from Apps processor to initialize each compute. session and vote for clock settings.
</p><p>
HVX can only be used by explicitly locking an HVX
</p><p>
context from each thread issuing HVX instructions, and unlocking after completion of HVX instructions.
</p></td></tr><tr><td><p>
SDM835
</p></td><td><p>
v62
</p></td><td><p>
aDSP (shared with audio)
</p></td><td><p>
Higher core frequency than SDM820/SDM821 at a given
</p><p>
voltage corner.
</p><p>
FastRPC supports domain handles and session restart. FastRPC supports 1-way IO Coherence to reduce Apps
</p><p>
processor cache maintenance overheads. Enabled by default.
</p><p>
Recommended dspCV_concurrency_query() lookup/eviction to
</p><p>
protect audio.
</p><p>
512 KB L2 cache partitioned 50%/50% during audio/compute
</p><p>
concurrency.
</p><p>
Recommended calling dspCV_init_with_attributes()
</p><p>
remotely from Apps processor to initialize each compute session and vote for clock settings.
</p><p>
HVX can only be used by explicitly locking an HVX
</p><p>
context from each thread issuing HVX instructions, and unlocking after completion of HVX instructions.
</p></td></tr><tr><td><p>
SDM660
</p></td><td><p>
v60
</p></td><td><div class="indent"><p>
cDSP
</p></div></td><td><p>
FastRPC supports domain handles and session restart. FastRPC supports 1-way IO Coherence to reduce Apps
</p><p>
processor cache maintenance overheads. Enabled by default.
</p><p>
Recommended to remove calls to
</p><p>
dspCV_concurrency_query().
</p><p>
512 KB L2 cache dedicated to cDSP. Recommended using HAP_power DCVS_V2 API's instead of
</p><p>
dspCV_init_with_attributes() to vote for clock settings.
</p><p>
HVX can only be used by explicitly locking an HVX
</p><p>
context from each thread issuing HVX instructions, and unlocking after completion of HVX instructions.
</p><p>
HVX Resource Manager helps facilitate time-sharing of
</p><p>
HVX contexts among concurrenct HVX applications.
</p></td></tr><tr><td><p>
SDM845
</p></td><td><p>
v65
</p></td><td><div class="indent"><p>
cDSP
</p></div></td><td><p>
FastRPC supports domain handles and session restart. FastRPC supports 1-way IO Coherence to reduce Apps
</p><p>
processor cache maintenance overheads. Enabled by default.
</p><p>
Recommended to remove calls to
</p><p>
dspCV_concurrency_query().
</p><p>
512 KB L2 cache dedicated to cDSP. Recommended using HAP_power DCVS_V2 API's instead of
</p><p>
dspCV_init_with_attributes() to vote for clock settings.
</p><p>
HVX context management moves inside the QuRT RTOS.
</p><p>
Applications may freely use HVX instructions without explicitly locking an HVX context. HVX contexts are saved/restored as needed during context switches.
</p></td></tr><tr><td><p>
SM8150
</p></td><td><p>
v66
</p></td><td><div class="indent"><p>
cDSP
</p></div></td><td><p>
FastRPC supports a QoS mode, for reducing round-trip
</p><p>
latency by constraining the sleep behavior of the Apps processor during FastRPC activity.
</p><p>
1024 KB L2 cache dedicated to cDSP. 4x128B HVX contexts, with no support for 64B mode.
</p></td></tr></table><h2>
<a name="Supported%20Hexagon/HVX%20Targets"></a>Supported Hexagon/HVX Targets
</h2><p>
Following are the targets supported by this SDK release, along with descriptions of what is new/unique to each.
</p><h3>
<a name="SDM820/821%20(Hexagon%20v60)"></a>SDM820/821 (Hexagon v60)
</h3><p>
On this target, HVX applications share the Hexagon v60 with audio and voice processing. Due to the high-priority low-latency requirements of audio and voice, HVX applications (except for camera streaming, which runs at highest priority with fixed resources) are subject to some constraints.
</p><h4>
<a name="L2%20Cache"></a>L2 Cache
</h4><p>
L2 cache is shared by all concurrent aDSP users. The runtime environment is tuned to seamlessly manage partitioning of the cache, depending on the concurrency present at any given time. For cache partitioning to work as designed, all concurrent applications must vote for resources through <a href="../DSP%20Power%20&amp;%20Perf.html#HAP%20Power%20API">HAP_power API's</a>, including the specification of the application's client class. (This vote is done by dspCV on behalf of its application inside <code>dspCV_init_with_attributes()</code>, which is described later).
</p><h4>
<a name="aDSP%20Eviction"></a>aDSP Eviction
</h4><p>
A well-behaved compute application should periodically (at least every 30 msec) check the aDSP concurrency level, and either terminate, pause, or migrate processing from the aDSP to the CPU if the concurrency is deemed too heavy. The <a href="../FastCV/Applications_Computer%20Vision.html#dspCV%20Library">dspCV library</a> offers a simple concurrency check API to advise a compute application whether it is safe to continue operating on the aDSP or not (based on currently existing concurrencies and target-specific thresholds). Usage of this API is demonstrated in the <a href="../Examples_ComputeHVX.html">Compute examples</a>, such as downscaleBy2.
</p><h4>
<a name="HVX%20context%20management"></a>HVX context management
</h4><p>
To use any HVX instructions, a SW thread must lock an HVX context (a.k.a. register file), and unlock when it is finished issuing HVX instructions. These contexts are managed by the Hexagon RTOS (i.e. QuRT), and are issued on a first-come, first-serve basis. Any SW thread issuing HVX instructions must first explicitly
</p><ul type="circle">
<li>
<p>
vote for HVX power via <a href="../DSP%20Power%20&amp;%20Perf.html#HAP%20Power%20API">HAP_power API</a> (recommended at the beginning of the HVX use case)
</p>
</li><li>
<p>
lock an HVX context via QuRT API (recommended just before each block of HVX functions, e.g. in each frame)
</p>
</li>
</ul><p>
And after finishing its sequence of HVX instructions, it must
</p><ul type="circle">
<li>
<p>
unlock its HVX context via QuRT API (recommended just after each block of HVX functions, e.g. in each frame)
</p>
</li><li>
<p>
Revoke its vote for HVX power via <a href="../DSP%20Power%20&amp;%20Perf.html#HAP%20Power%20API">HAP_power API</a> (recommended at the end of the HVX use case)
</p>
</li>
</ul><p>
The QuRT API's are documented in the QuRT User Guide, located at 80-VB419-78 Hexagon QuRT RTOS User Guide (available at ${HEXAGON_SDK_ROOT}/tools/Hexagon_Tools/&lt;tools version&gt;/Documents), and the details about HAP_Power APIs can be found <a href="../DSP%20Power%20&amp;%20Perf.html#HAP%20Power%20API">here</a>. The <a href="../FastCV/Applications_Computer%20Vision.html#dspCV%20Library">dspCV library</a> offers API's that abstract these details, as demonstrated in the <a href="../Examples_ComputeHVX.html">Computer Vision Examples</a> downscaleBy2 example. Note that HVX contexts may be locked by a thread in either a blocking or non-blocking call, and may be locked in 64-byte or 128-byte mode. Additionally, it is possible for the caller to reserve multiple HVX contexts on behalf of its user process, prior to locking any of them. This is helpful in multi-threaded implementations, in that the set up of the multiple threads can be done with certainty that their HVX unit lock attempts will succeed without blocking.
</p><p>
Using HVX as a shared resource involves several considerations.
</p><table><tr><th><p>
Consideration
</p></th><th><p>
Comments
</p></th></tr><tr><td><p>
64-byte vs. 128-byte mode
</p></td><td><p>
Generally 128-byte mode is recommended, since it is possible to fully utilize the HVX hardware with half as many HW threads as in 64-byte mode. This leaves more processing resource open for non-HVX concurrencies, e.g. audio.
</p><p>
Further, it is ideal to be consistent in using one mode (i.e. 128-byte) across all HVX functions that may be concurrent, as the mode is global, meaning any threads trying to use a the other mode (i.e. 64-byte) will not be able to lock an otherwise available HVX context until all 128-byte users release their locks.
</p><p>
And finally, if C HVX intrinsics are used, the compiler must be hinted whether the mode used at run time will be 64 or 128, so consistency is recommended. Files compiled with -mhvx will assume 64-byte mode, and files compiled with -mhvx-double will assume 128-byte mode.
</p><p>
Note that assembly code often can be written agnostically of the mode, with the vector length passed as a run-time argument.
</p><p>
<b>Summary:</b> Always use 128-byte mode unless there is a compelling reason to use 64, and concurrencies with 128-byte users can be avoided.
</p></td></tr><tr><td><p>
When to use HVX context reservation (prior to HVX context lock) API?
</p></td><td><p>
This is recommended if there will be multiple threads trying to lock HVX, and it is desirable to resolve ahead of time how many can be locked. It is not recommended to hold an HVX reservation throughout use case duration, as it will prevent any possible HVX concurrency.
</p></td></tr><tr><td><p>
When to use blocking or non-blocking call to lock HVX context?
</p></td><td><p>
Non-blocking is preferred if there is a fall-back option (i.e. non-HVX implementation for the same function), or if an error code should be immediately returned to the caller. Blocking should only be used if use case is tolerant of an indefinitely-long blockage to wait for other users of HVX to release context locks.
</p></td></tr><tr><td><p>
What if HVX is not available?
</p></td><td><p>
If HVX reservation or lock is not available, the implementation should either fail back to the application (which might pause, terminate, or transition to a CPU implementation), or complete the request using a non-HVX implementation of the same algorithm (with lower performance expected).
</p></td></tr></table><h4>
<a name="Clocks%20Setup"></a>Clocks Setup
</h4><p>
Every application running on the aDSP is required to vote for its Hexagon MHz and bus bandwidth requirements. The recommended voting method for SDM820/821 is to invoke <code>dspCV_init_with_attributes</code> remotely from the application, as described in <a href="../FastCV/Applications_Computer%20Vision.html#dspCV%20Library">dspCV library</a>, and demonstrated in the <a href="../Examples_ComputeHVX.html">Computer Vision Examples</a>.
</p><h4>
<a name="SDM820/SDM821%20Hexagon/HVX%20Documents%20and%20Resources"></a>SDM820/SDM821 Hexagon/HVX Documents and Resources
</h4><ul type="circle">
<li>
<p>
80-NV396-32 Hexagon aDSP HVX Overview for MSM8996/MSM8998 (available in CreatePoint)
</p>
</li><li>
<p>
80-N2040-30 Hexagon V60 HVX Programmers Reference Manual (available in Hexagon Tools document bundle)
</p>
</li><li>
<p>
80-VB419-97 Hexagon HVX Vector Extension Programming (available in CreatePoint)
</p>
</li><li>
<p>
80-VB419-78 Hexagon QuRT RTOS User Guide (available at ${HEXAGON_SDK_ROOT}/tools/Hexagon_Tools/&lt;tools version&gt;/Documents)
</p>
</li><li>
<p>
80-NF772-36 Introduction to HVX Streaming for Camera for MSM8996/8998 (available in CreatePoint)
</p>
</li><li>
<p>
Single-threaded HVX Code simulator examples in Hexagon Tools (8.0.x and higher) distribution (&lt;Tools Location&gt;/examples/HVX)
</p><ul type="circle">
<li>
<p>
For more details, see the README files in the HVX folder, and in each example folder. These single-threaded examples are for simulation only.
</p>
</li>
</ul>
</li><li>
<p>
<a href="../Examples_ComputeHVX.html">Multi-threaded HVX code simulator/target examples</a>
</p>
</li><li>
<p>
<a href="../Camera%20streaming/Applications.html">Camera Streaming framework and examples</a>
</p>
</li><li>
<p>
<a href="../FastCV/Applications_Computer%20Vision.html#dspCV%20Library">dspCV Library</a>
</p>
</li>
</ul><h3>
<a name="SDM835%20(Hexagon%20v62)"></a>SDM835 (Hexagon v62)
</h3><p>
SDM835 is largely the same as SDM820/SDM821, with the following differences:
</p><ul type="circle">
<li>
<p>
Hexagon is clocked at a higher frequencies for each voltage corner.
</p>
</li><li>
<p>
Hexagon version is v62, which contains several new instructions.
</p>
</li><li>
<p>
FastRPC buffers are 1-way IO Coherent. Transparent to user, Apps processor cache maintenance within FastRPC is reduced.
</p>
</li><li>
<p>
FastRPC adds support for domains and session restart. See <a href="../APIs_FastRPC.html">FastRPC</a> for details. See benchmark at <a href="../Examples_ComputeHVX.html">Computer Vision Examples</a> for example domain handle usage.
</p>
</li><li>
<p>
<a href="../DSP%20Power%20&amp;%20Perf.html#HAP%20Power%20API">HAP_power</a> introduces the DCVS_v2 API for simplified clock voting. If the libdspCV_skel.so shipped on SDM835 devices is replaced by the libdspCV_skel.so built from this SDK, user is recommended to follow the new SDM660 Clocks Setup recommendation below. Otherwise, continue using <code>dspCV_init_with_attributes()</code> as in SDM820/SDM821.
</p>
</li><li>
<p>
C++ 11 and 14 standards are supported.
</p>
</li><li>
<p>
A new USB <a href="../Debugging_Target.html">on-target debugger</a> is available.
</p>
</li>
</ul><h4>
<a name="SDM835%20Hexagon/HVX%20Documents%20and%20Resources"></a>SDM835 Hexagon/HVX Documents and Resources
</h4><p>
Same as above for SDM820/SDM821, plus
</p><ul type="circle">
<li>
<p>
80-N2040-37 Hexagon V62 HVX Programmers Reference Manual (available in Hexagon Tools document bundle)
</p>
</li>
</ul><h3>
<a name="SDM660%20(Hexagon%20v60)"></a>SDM660 (Hexagon v60)
</h3><p>
Following are the key changes in SDM660.
</p><h4>
<a name="Removal%20of%20audio/voice%20concurrency%20considerations"></a>Removal of audio/voice concurrency considerations
</h4><p>
SDM660 has a new Compute DSP (cDSP) subsystem, separated from the aDSP to isolate audio/voice from imaging/compute processing. With this split,
</p><ul type="circle">
<li>
<p>
The Hexagon version is reverted back to v60, same as on SDM820.
</p>
</li><li>
<p>
The L2 is no longer partitioned during concurrency, the 512KB is always available to imaging/compute applications running on the cDSP.
</p>
</li><li>
<p>
It is no longer recommended to use dspCV to query for concurrency to determine if it is safe to use the cDSP. Access to cDSP resources is moderated by thread priority and explicit HVX locking. It is left to applications to determine if their required QoS is not being met, and to take their own corrective actions.
</p>
</li>
</ul><h4>
<a name="HVX%20Context%20Management"></a>HVX Context Management
</h4><p>
To better facilitate time-sharing of HVX contexts among concurrent applications, an HVX resource manager has been introduced in sysmon. Details are described <a href="../APIs_DSP%20Clk%20&amp;%20Rsrc%20Mgmt.html">here</a>. This resource manager wraps existing QuRT HVX lock/unlock and reserve functions, using configurable time-outs to help more reserve and lock attempts succeed within reasonable time.
</p><h4>
<a name="_Clocks%20Setup"></a>Clocks Setup
</h4><p>
Starting in SDM660, the recommendation is to remove any linkage or reference to dspCV (such as calls to <code>dspCV_init_with_attributes()</code>) from the Apps processor. The reasons are:
</p><ul type="circle">
<li>
<p>
Simplifying Apps side dependencies to make domain/session restart easier.
</p>
</li><li>
<p>
FastRPC has instituted default voting for compute sessions, targeting nominal operation, which may be good enough for most applications. If desired, applications may override default settings by voting into <a href="../DSP%20Power%20&amp;%20Perf.html#HAP%20Power%20API">HAP_power</a>, for example with a DCVS_v2 payload, from the applications handle open implementation, or other custom initialization or clock setup function.
</p>
</li><li>
<p>
dspCV has added a static constructor which automatically performs all the required initializations previously done in <code>dspCV_init_with_attributes</code> (except for clock settings), whenever a shared object that is dynamically linked to libdspCV_skel.so is loaded.
</p>
</li>
</ul><p>
This new recommendation for clocks setup (for a scenario in which the session default is over-ridden) is demonstrated in the benchmark example in the <a href="../Examples_ComputeHVX.html">Computer Vision examples</a>.
</p><h4>
<a name="SDM660%20Hexagon/HVX%20Documents%20and%20Resources"></a>SDM660 Hexagon/HVX Documents and Resources
</h4><p>
Same as above for SDM820/SDM821, plus
</p><ul type="circle">
<li>
<p>
80-P8754-31 Hexagon CDSP HVX Overview for SDM660 (available in CreatePoint)
</p>
</li>
</ul><h3>
<a name="SDM845/SDM670/SDM710%20(Hexagon%20v65)"></a>SDM845/SDM670/SDM710 (Hexagon v65)
</h3><p>
SDM845, like SDM660, has a separate cDSP for imaging/compute use cases. The guidelines for SDM660 given above are also relevant for SDM845, with several additional key differences:
</p><ul type="circle">
<li>
<p>
Significantly faster clocking (peak frequency around 1.2 GHz).
</p>
</li><li>
<p>
Adds a 256KB internal TCM (Vector TCM, or VTCM) with better latency and BW performance than L2.
</p>
</li><li>
<p>
Hexagon v65 contains many new instructions, including scatter and gather instructions (which only operate within VTCM). More information about VTCM and scatter/gather are given in <i>HVX v65 Features</i> (Createpoint document number 80-P9301-84).
</p>
</li><li>
<p>
Planned as the (likely) last target to support 64-byte HVX mode, recommendation is to converge software to 128-byte mode.
</p>
</li><li>
<p>
The QuRT RTOS has integrated HVX register files (a.k.a. contexts) into its regular context save and restore operations. Calls to lock and unlock HVX contexts are no longer required in most cases, with the following exceptions:
</p><ul type="circle">
<li>
<p>
While 128-byte mode is default, <code>qurt_hvx_lock()</code> or <code>dspCV_hvx_lock()</code> can still be used, for now, to secure 64-byte mode operation for the requesting thread (all threads wanting 64-byte mode must use either these legacy, or the new <code>qurt_hvx_set()</code> API.
</p>
</li><li>
<p>
If a thread has completed a set of HVX instructions but will continue running non-HVX instructions for a considerable time before any system call (e.g. mutex or signal wait), it is advisable to explicitly unlock the HVX context via <code>qurt_hvx_unlock()</code>, <code>dspCV_hvx_unlock()</code>, or the new <code>qurt_hvx_set()</code>. This can be done even if the context was never explicitly locked, and serves as a hint to the RTOS that the HVX context can be freed. The RTOS may then reassign the HVX context to another SW thread without performing a save/restore of the registers. (If the same thread that unlocked its context later wants to resume using HVX, it may do so, and the RTOS will acquire a new HVX context for it upon the first encountered HVX instruction, or call to one of the explicit locking API's).
</p>
</li>
</ul>
</li><li>
<p>
For cDSP applications linked to libdspCV_skel.so, there is no longer a need to explicitly power on HVX via <code>dspCV_hvx_power_on()</code>. This is done implicitly in the dspCV static constructor.
</p>
</li>
</ul><p>
benchmark_v65 is a new example at <a href="../Examples_ComputeHVX.html">Computer Vision examples</a> that illustrates the new features and best practices for SDM845 and beyond. (The older examples should also work as-is on SDM845).
</p><ul type="circle">
<li>
<p>
FastRPC domains - src_app/benchmark.c application demonstrates one way to look up the availability of cDSP and prefer to offload to it instead of aDSP.
</p>
</li><li>
<p>
FastRPC session restart - the <code>-f crash10</code> option demonstrates a crash in the benchmark cDSP application, along with how to restart that session and recover operation in src/benchmark.c.
</p>
</li><li>
<p>
Clock Setting - Demonstrates a custom function <code>benchmark_setClocks()</code> for voting clocks via the HAP_power DCVS_v2 API.
</p>
</li><li>
<p>
dspCV static constructor - Dynamic linking of libdspCV_skel.so from libbenchmark_skel.so causes dspCV's static constructor to invoke at load time, hence creating the worker pool and powering on HVX implicitly.
</p>
</li><li>
<p>
VTCM and scatter/gather - the <code>-f bilateral</code> option uses VTCM and scatter/gather in its implementation. See src_dsp/bilateral_imp.c for calls to HAP_vtcm_manager and related logic for allocating and using VTCM. See asm_src/bilateral_v65.S for assembly code that uses scatter/gather instructions.
</p>
</li><li>
<p>
Multi-threading - for HVX jobs, it is recommended to choose the number of worker threads based on the global variable dspCV_num_hvx128_contexts. For scalar workloads, dspCV_num_workers is recommended. These will set the number of workers appropriately to maximally use available resources (HVX 128B contexts, and number of HW threads, respectively) on the given target.
</p>
</li><li>
<p>
dspCV_hvx_prepare_mt_job is no longer recommended for use. Now that QuRT supports HVX concurrencies smoothly, this function would only cause extra overhead and possible confusion.
</p>
</li>
</ul><p>
The steps required for building and running the benchmark application on target are shown in the build.cmd and benchmark_v65_walkthrough.py scripts, respectively.
</p><h4>
<a name="SDM845%20Hexagon/HVX%20Documents%20and%20Resources"></a>SDM845 Hexagon/HVX Documents and Resources
</h4><p>
Same as above for SDM660, plus
</p><ul type="circle">
<li>
<p>
80-N2040-41 Hexagon V65 HVX Programmers Reference Manual (available in Hexagon Tools document bundle)
</p>
</li><li>
<p>
80-P9301-84 HVX v65 Features
</p>
</li>
</ul><h3>
<a name="SM8150%20(Hexagon%20v66)"></a>SM8150 (Hexagon v66)
</h3><p>
SM8150 contains a Hexagon v66g_1024 architecture:
</p><ul type="circle">
<li>
<p>
Significantly faster clocking (peak frequency around 1.4 GHz).
</p>
</li><li>
<p>
HVX capability is doubled, with 4x128B units, and discontinued support for 64B mode.
</p>
</li><li>
<p>
Scalar MAC and Floating Point capability is doubled, with each cluster now having its own dedicated units.
</p>
</li><li>
<p>
L2 size is increased to 1024 KB.
</p>
</li><li>
<p>
New instructions increasing neural network performance (available via Hexagon NN library).
</p>
</li>
</ul><p>
benchmark_v65 is the best general example and recommended starting point for v65 and v66 development.
</p><h4>
<a name="SM8150%20Hexagon/HVX%20Documents%20and%20Resources"></a>SM8150 Hexagon/HVX Documents and Resources
</h4><p>
Same as above for SDM845, plus
</p><ul type="circle">
<li>
<p>
80-N2040-42 Hexagon V66 Programmers Reference Manual (available in Hexagon Tools document bundle)
</p>
</li><li>
<p>
80-N2040-44 Hexagon V66 HVX Programmers Reference Manual
</p>
</li>
</ul><h2>
<a name="Hexagon/HVX%20Libraries"></a>Hexagon/HVX Libraries
</h2><p>
The following libraries of accelerated functions are available in this SDK.
</p><h3>
<a name="Hexagon%20NN"></a>Hexagon NN
</h3><p>
The <a href="../images/80-VB419-110_Hexagon_NN_Library_User_Guide.pdf">Hexagon NN library</a> offers API's to construct and execute neural networks optimized on HVX.
</p><ul type="circle">
<li>
<p>
${HEXAGON_SDK_ROOT}/libs/hexagon_nn
</p>
</li>
</ul><p>
Usage tutorials are also available:
</p><ul type="circle">
<li>
<p>
${HEXAGON_SDK_ROOT}/examples/hexagon_nn/tutorials
</p>
</li>
</ul><h3>
<a name="FastCV"></a>FastCV
</h3><p>
The <a href="../FastCV/Applications_Computer%20Vision.html#FastCV%20Library">FastCV library</a> at ${HEXAGON_SDK_ROOT}/libs/fastcv/fastcv contains several hundred functions optimized for Hexagon v5x (i.e. scalar). Some of these are further optimized for HVX.
</p><h3>
<a name="qmath"></a>qmath
</h3><p>
qmath is a collection of accelerated math routines. Initially, it supports a set of pseudo-floating-point arithmetic operations on HVX vectors. For more information on supported API's, performance, and accuracy, see <a href="../images/80-VB419-105_Qualcomm_Math_Library.pdf">qmath library</a>. For example usage, see the qmath example at
</p><ul type="circle">
<li>
<p>
${HEXAGON_SDK_ROOT}/examples/qmath/qmath_sample_8996 (for MSM8996, which does not support multi-domain FastRPC).
</p>
</li><li>
<p>
${HEXAGON_SDK_ROOT}/examples/qmath/qmath_sample (for all other targets).
</p>
</li>
</ul><p>
This simple example solves the quadratic equation over vectors of pseudo-floating-point values, and provides profiling and accuracy comparisons to native float.
</p><p align="center" style="display:block;padding-top: 50px;">
  Copyright &#169; 2018 Qualcomm Technologies Inc. All rights reserved.

</p><a style="display:block;padding-bottom: 700px;"></a></div></div>
</body>
</html>
