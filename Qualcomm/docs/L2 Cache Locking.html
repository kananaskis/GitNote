<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style type="text/css">
table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}
td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}

.smarkdoc {
  margin-left: 42px; margin-right: 42px;
  font-size: 13px;
  font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif;
}

h1, h2, h3 { color: #3c4c6c; }
h1 {
  text-align: center;
  font-size: 200%;
/*    margin-left: -30px; */
  clear: both;
}
h2 {
  font-size: 160%;
  margin: 32px -40px 24px -42px;
  padding: 3px 24px 8px;
  border-bottom: 2px solid #5088c5;
  clear: both;
}
h3 {
  font-size: 130%;
  margin: 20px -4px 10px;
  padding: 4px;
  clear: both;
}
h4 {
  font-size: 110%;
  margin: 2em 0 1em;
}

pre {
  font-size: 90%;
  background-color: #f0f0f4; padding: 6px; border: 1px solid #d0d0ee;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

.pre {
  font-size: 90%;
  padding: 6px;
  background-color: #f0f0f4;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

code {
  font-size: 90%;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

h3 code {
  font-size: 100%;
}

p {
  margin: 0.8em 0;
}
ul, ol {
  margin: 1em 0 1em 3em; padding: 0;
}
div.indent {
  margin: 0 3em;
}

a[href] {
  text-decoration: none;
  color: #2020b0;
}
a[href]:hover {
  border-bottom: 1px dotted #2030d0;
}

/* Smark Users Guide */

.codebox {
  padding: 0 1px;  margin-right:1px;
  border:1px solid #d0d0ee;
  background-color: #f0f0f4;
  font-weight: bold;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* .art .line {  -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.3); } */

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console";
   margin-left: auto; margin-right: auto;
   background-color: white;
   /* border: 1px solid #555; */  /* Useful for non-white pages */
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
.toc {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em;
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}

/* ================ Print ================ */

@media print {

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 3in 0 20px; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em -2em }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}

/* ================  Layout  ================ */
/*
 *  +------------------------+
 *  |         #header        |
 *  +----------+-------------+
 *  | #sidebar |  #content   |
 *  |          |             |
 *  +----------+-------------+
 *
 * CSS padding, border width, and border style (!) affect the actual height
 * (and in turn layout).
 */

#header {
  position: fixed;
  top: 0px;
  height: 32px;
  left: 0px;
  width: 100%;
  padding: 10px 10px 0 0;
}
#sidebar {
  position: fixed;
  top: 42px;
  bottom: 0px;
  left: 0px;
  min-width: 180px;
  overflow: auto;
  border: 1px solid transparent;
  border-width: 0 1px 0 1px;
  padding: 0px 5px 0px 5px;
}
#content {
  position: fixed;
  top: 60px;
  left: 200px;
  bottom: 0px;
  right: 0px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding: 10px 20px;
  padding-top: 0;
}

/* ================  Styles  ================ */


body {
  font-family: "Lucida Grande", Helvetica, Arial, sans-serif;
  font-size: 16px;
}

#header {
  color: #fff;
  background: #555;
  text-align: center;
  font-size: 25px;
}

#sidebar {
  color: #000;
  background: #eee;
  border-right: 1px solid #bbb;
  text-align: left;
  font-size: 12px;
  line-height: 50%;
}

#sidebar h1 {
  margin: 0 0 0 0;
  border-left: 5px solid transparent;
  text-align: left;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}

#sidebar h2 {
  margin: 2px 0 8px 0;
  border-left: 5px solid transparent;
  text-align: center;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}



#content {
  margin: 0;
  font-size: 13px;
  line-height: 160%;
}

#content h1, #content h2 {
  border-bottom: 2px solid;
  font-size: 1.8em;
  font-weight: normal;
  margin: 2.0em 0px 1.3em 0px;
  padding-bottom: 0.6em;
  text-align: left;
}

#content h3 {
  color: #242220;
  font-size: 1.4em;
  font-weight: normal;
  margin: 2em 0px 0.8em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}
#content h4 {
  font-size: 1.2em;
  font-weight: normal;
  margin: 2em 0px 0.5em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}

a[href] {
  color: #05c;
  text-decoration: none;
}

#sidebar a {
  /*text-shadow:  1px 1px 2px #fff, -1px -1px #ddd;*/
  line-height: 40%;
}

pre, code {
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
  font-family: "Monaco", monospace;  font-size: 90%;
  background-color: #f8f8fa;
  border: 1px solid #e4e4ee;
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  border-radius: 2px;
  padding: 1px 0 0 1px;
}

pre {
  padding: 2px 4px;
}

table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}

/* Highlight currently-selected sidebar link */

#sidebar a.thisfile {
  color: #557;
}

/* indentation */

#content {
   padding-left: 60px;
}
#content h1, 
#content h2, 
#content h3, h4 {
    margin-left: -30px;
}

h3 > code {
    font-size: 80%;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV 
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console"; 
   margin-left: auto; margin-right: auto;
   background-color: white;
   border: 1px solid #555;
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
/*
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
*/

.toc {
  column-count: 1; column-gap: 2em;
  -moz-column-count: 1; -moz-column-gap: 2em;
  -webkit-column-count: 1; -webkit-column-gap: 2em; 
   alternate: column-width: 235px; column-rule-width: 5px;
}


.columns {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em; p
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}


/* ================ Print ================ */

@media print {

  #header, #content { position: static; }
  #sidebar { display: none; }

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 1in 0 1in; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em 0 }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}


</style><style type="text/css">
.search { right: 20pt; position: fixed; top: 5pt }

</style><title>CDSP L2 Cache Locking HAP Interface</title>
</head><body>
<div class="smarkdoc"><div id="header">Hexagon SDK 3.4.3</div><div id="sidebar"><top><img src="images/sidebar_top.jpg"></top><script src="scripts/post.js" type="text/javascript"></script><form class="search" id="searchForm"><input id="searchquery" name="q" onkeydown="postFunctionKeydown(event, false)"><input id="searchButton" onclick="postFunction(false)" type="button" value="Search"></form><p>
<a href="index.html">Quick start</a>
</p><hr>
<p>
<a href="feature_matrix.html">Feature Matrix</a>
</p><hr>
<p>
<a href="hexagon_architecture.html">Hexagon Architecture</a>
</p><hr>
<p>
<a href="images/Hexagon_Document_Bundle.pdf#page=2881">Hexagon Compiler/Linker</a>
</p><hr>
<p>
<a href="hexagon_libraries.html">Hexagon Standard Libraries</a>
</p><hr>
<p>
<a href="images/80-VB419-178_QuRT_User_Guide.pdf">Hexagon RTOS</a>
</p><hr>
<p>
<a href="images/80-VB419-108_Hexagon_DSP_User_Guide.pdf">Hexagon DSP Programming</a>
</p><hr>
<h3>
<a name="Platforms"></a>Platforms
</h3><p>
<a href="Platforms_HLOS.html">HLOS</a>
</p><p>
<a href="Platforms_Simulator.html">Simulator</a>
</p><p>
<a href="Platforms_Target.html">Target</a>
</p><hr>
<h3>
<a name="Environments"></a>Environments
</h3><p>
<a href="Environments_Build%20System.html">Build System</a>
</p><p>
<a href="Environments_Build%20System%20Porting.html">Build System Porting</a>
</p><p>
<a href="Environments_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="ArchitectureOverview"></a>ArchitectureOverview
</h3><p>
<a href="HVX/ArchitectureOverview.html">HVX</a>
</p><hr>
<h3>
<a name="Applications"></a>Applications
</h3><p>
<a href="Audio/Applications.html">Audio</a>
</p><p>
<a href="Camera%20streaming/Applications.html">Camera streaming</a>
</p><p>
<a href="Applications_Compute%20offload.html">Compute offload</a>
</p><p>
<a href="FastCV/Applications_Computer%20Vision.html">Computer Vision</a>
</p><p>
<a href="Neural%20Networks/Applications.html">Neural Networks</a>
</p><p>
<a href="Voice/Applications.html">Voice</a>
</p><hr>
<h3>
<a name="APIs"></a>APIs
</h3><p>
<a href="APIs_Async%20Message%20Queue.html">Async Message Queue</a>
</p><p>
<a href="APIs_DSP%20Clk%20&amp;%20Rsrc%20Mgmt.html">DSP Clk &amp; Rsrc Mgmt</a>
</p><p>
<a href="APIs_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="APIs_FastRPC.html">FastRPC</a>
</p><hr>
<h3>
<a name="Examples"></a>Examples
</h3><p>
<a href="Audio/Examples.html">Audio</a>
</p><p>
<a href="Camera%20streaming/Examples.html">Camera streaming</a>
</p><p>
<a href="Examples_Common.html">Common</a>
</p><p>
<a href="Examples_ComputeHVX.html">ComputeHVX</a>
</p><p>
<a href="Examples_GeneralOverview.html">GeneralOverview</a>
</p><p>
<a href="Neural%20Networks/Examples.html">Neural Networks</a>
</p><hr>
<h3>
<a name="Testing"></a>Testing
</h3><p>
<a href="CAPIv2/Testing_CAPIv2%20Unit%20Tests.html">CAPIv2 Unit Tests</a>
</p><p>
<a href="Testing_Eclipse%20Unit%20Tests.html">Eclipse Unit Tests</a>
</p><hr>
<h3>
<a name="Debugging"></a>Debugging
</h3><p>
<a href="Debugging_Connect%20to%20Device.html">Connect to Device</a>
</p><p>
<a href="Debugging_Exceptions.html">Exceptions</a>
</p><p>
<a href="Debugging_Message%20Logging.html">Message Logging</a>
</p><p>
<a href="Debugging_Simulator.html">Simulator</a>
</p><p>
<a href="Debugging_Target.html">Target</a>
</p><hr>
<h3>
<a name="Tools"></a>Tools
</h3><p>
<a href="Tools_Hexagon%20Tools%208.3.html">Hexagon Tools 8.3</a>
</p><p>
<a href="Tools_IDL%20Compiler.html">IDL Compiler</a>
</p><p>
<a href="Tools_On%20Target%20Profiling.html">On Target Profiling</a>
</p><p>
<a href="Tools_Scripts.html">Scripts</a>
</p><p>
<a href="Tools_Signing.html">Signing</a>
</p><p>
<a href="Tools_UserGuides.html">UserGuides</a>
</p><p>
<a href="Tools_Utilities.html">Utilities</a>
</p><hr>
<h3>
<a name="FAQ"></a>FAQ
</h3><p>
<a href="FAQ_Common.html">Common</a>
</p><p>
<a href="FAQ_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="FAQ_FastRPC.html">FastRPC</a>
</p><p>
<a href="FAQ_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="Dependencies"></a>Dependencies
</h3><p>
<a href="Dependencies_Common.html">Common</a>
</p><hr>
<h3>
<a name="Release%20Notes"></a>Release Notes
</h3><p>
<a href="Release%20Notes_Common.html">Common</a>
</p><hr>
<h3>
<a name="Support"></a>Support
</h3><p>
<a href="Support_Contact.html">Contact</a>
</p><center><img src="images/sidebar_bot.jpg"></center></div><div id="content"><a name="_top_" style="display:block;"></a><h1>
<a name="CDSP%20L2%20Cache%20Locking%20HAP%20Interface"></a>CDSP L2 Cache Locking HAP Interface
</h1><div class="toc"><div class="tocLevel"><a href="#Supported%20Chipsets">Supported Chipsets</a></div><div class="tocLevel"><a href="#Overview">Overview</a></div><div class="tocLevel"><a href="#API's">API's</a><div class="tocLevel"><a href="#HAP_cache_lock">HAP_cache_lock</a></div><div class="tocLevel"><a href="#HAP_cache_unlock">HAP_cache_unlock</a></div><div class="tocLevel"><a href="#HAP_query_avail_cachelock">HAP_query_avail_cachelock</a></div><div class="tocLevel"><a href="#HAP_query_total_cachelock">HAP_query_total_cachelock</a></div><div class="tocLevel"><a href="#HAP_cache_lock_addr">HAP_cache_lock_addr</a></div><div class="tocLevel"><a href="#HAP_cache_unlock_addr">HAP_cache_unlock_addr</a></div></div><div class="tocLevel"><a href="#Usage">Usage</a></div></div><h2>
<a name="Supported%20Chipsets"></a>Supported Chipsets
</h2><p>
CDSP: SDM845, SDM670, SM8150, SM6150, QCS605
</p><h2>
<a name="Overview"></a>Overview
</h2><p>
Cache locking driver on CDSP provides a way to user to lock the cache for required memory size. Once processing is done on locked memory then user can put the request to unlock the same.
</p><p>
Previous approach for cache locking: <code>HAP_power_set_linelock</code> and <code>HAP_power_set_linelock_nothrottle</code> by <code>HAP_power_set API</code> is deprecated now due to below limitations:
</p><ol type="1">
<li>
<p>
There was no way to track the total locked cache which can be useful information in debugging.
</p>
</li><li>
<p>
No limit on cache size to be locked which can result in complete cache locked and hence might affect the other running applications.
</p>
</li><li>
<p>
As client used to allocate the memory and pass the memory address for locking so in case of multiple lock requests there is possibility of cache lines overlap which can result in lock failure even though there is cache available for locking.
</p>
</li>
</ol><p>
But this new cache locking manager effectively handles the multiple cache lock requests by allocating the memory on client behalf and avoids the possibility of cache lines overlap to utilize the available cache for locking in best way. Framework also limits maximum cache that can be locked to guarantee the performance of guestOS and FastRPC threads.
</p><p>
Framework also provides query APIs to get the maximum available cache size for locking and total locked cache at that moment. It helps applications to make the cache lock requests accordingly and also to monitor the total locked cache at any point of time.
</p><p>
Also, there is separate cache lock, unlock APIs where user can pass address of memory to be locked along with size information. These APIs are mainly useful in applications where user is particular about the address to lock, for example in code/library locking case.
</p><p>
Following sections explains APIs in detail and how to use them.
</p><h2>
<a name="API's"></a>API's
</h2><h3>
<a name="HAP_cache_lock"></a>HAP_cache_lock
</h3><p>
Allocates memory and locks cache for given memory size (in Bytes) and returns locked virtual address.
</p><table><tr><th><p>
API
</p></th><td><p>
void* <b>HAP_cache_lock</b> (unsigned int <b>size</b>, unsigned long long* <b>paddr_ptr</b>)
</p></td></tr><tr><th><p>
size
</p></th><td><p>
Memory size (in Bytes) to be locked. For SDM845, SDM670 maximum size limit is 384KB.
</p></td></tr><tr><th><p>
paddr_ptr
</p></th><td><p>
To get the locked 64bit physical address. If physical address is not needed then can pass NULL.
</p></td></tr><tr><th><p>
Return
</p></th><td><p>
Returns locked virtual address. In case of failure returns 0.
</p></td></tr></table><h3>
<a name="HAP_cache_unlock"></a>HAP_cache_unlock
</h3><p>
Unlocks cache and deallocates memory based on given virtual address.
</p><table><tr><th><p>
API
</p></th><td><p>
int <b>HAP_cache_unlock</b> (void* <b>vaddr_ptr</b>)
</p></td></tr><tr><th><p>
vaddr_ptr
</p></th><td><p>
Virtual address of memory block to unlock.
</p></td></tr><tr><th><p>
Return
</p></th><td><p>
Returns success -&gt; 0 else failure -&gt; non-zero value.
</p></td></tr></table><h3>
<a name="HAP_query_avail_cachelock"></a>HAP_query_avail_cachelock
</h3><p>
Query API to get the size of max contiguous memory block available for cache locking.
</p><table><tr><th><p>
API
</p></th><td><p>
int <b>HAP_query_avail_cachelock</b> (void)
</p></td></tr><tr><th><p>
Return
</p></th><td><p>
In case of failure returns -1 else available size (in Bytes).
</p></td></tr></table><h3>
<a name="HAP_query_total_cachelock"></a>HAP_query_total_cachelock
</h3><p>
Query API to get the total locked cache size.
</p><table><tr><th><p>
API
</p></th><td><p>
int <b>HAP_query_total_cachelock</b> (void)
</p></td></tr><tr><th><p>
Return
</p></th><td><p>
In case of failure returns -1 else total locked cache size (in Bytes).
</p></td></tr></table><h3>
<a name="HAP_cache_lock_addr"></a>HAP_cache_lock_addr
</h3><p>
Locks cache for given virtual address and memory size (in Bytes). Address and size should be aligned to 32 bytes and size should not be more than 64KB. At any point of time, only one such request will be honored and other lock requests using this API will fail until the existing one requests for unlock. This API expects address argument from user to lock, so it should be used when user is particular about address to lock like in code/library locking case. If not particular about the address then preferred API is &#8220;HAP_cache_lock&#8221; as it avoids scattered cache locks in order to use available cache in optimized way.
</p><table><tr><th><p>
API
</p></th><td><p>
int <b>HAP_cache_lock_addr</b> (void* <b>vaddr_ptr</b>, unsigned int <b>size</b>)
</p></td></tr><tr><th><p>
vaddr_ptr
</p></th><td><p>
Virtual address of memory block to lock, should be 32 byte aligned.
</p></td></tr><tr><th><p>
size
</p></th><td><p>
Memory size (in Bytes) to be locked, should be 32 byte aligned and not more than 64KB.
</p></td></tr><tr><th><p>
Return
</p></th><td><p>
Returns success -&gt; 0 else failure -&gt; non-zero value.
</p></td></tr></table><h3>
<a name="HAP_cache_unlock_addr"></a>HAP_cache_unlock_addr
</h3><p>
Unlocks cache for given virtual address. This API should be used along with <code>HAP_cache_lock_addr</code> API.
</p><table><tr><th><p>
API
</p></th><td><p>
int <b>HAP_cache_unlock_addr</b> (void* <b>vaddr_ptr</b>)
</p></td></tr><tr><th><p>
vaddr_ptr
</p></th><td><p>
Virtual address of memory block to unlock.
</p></td></tr><tr><th><p>
Return
</p></th><td><p>
Returns success -&gt; 0 else failure -&gt; non-zero value.
</p></td></tr></table><h2>
<a name="Usage"></a>Usage
</h2><p>
Following examples illustrates usage of cache locking APIs:
</p><p>
Example 1: User requests cache lock for 64KB, 32KB and after processing unlocks the same in end.
</p><pre><span style="color: darkgreen">/* Query to get the max contiguous memory block available for cache locking */</span>
<span style="color: blue">int</span> avail_size = HAP_query_avail_cachelock();
<span style="color: darkgreen">/* If "avail_size" &gt;= 64KB then request for 64KB lock */</span>
<span style="color: blue">unsigned</span> <span style="color: blue">long</span> <span style="color: blue">long</span> paddr;
<span style="color: blue">void</span>* vaddr_ptr = HAP_cache_lock(64*1024, &amp;paddr);  <span style="color: darkgreen">//Returns locked virtual address and corresponding 64bit physical address.</span>
<span style="color: darkgreen">/* Query again to get the max contiguous memory block available for cache locking */</span>
avail_size = HAP_query_avail_cachelock();
<span style="color: darkgreen">/* If "avail_size" &gt;= 32KB then request for 32KB lock */</span>
<span style="color: blue">void</span>* vaddr_ptr_1 = HAP_cache_lock(32*1024, NULL);  <span style="color: darkgreen">//Returns locked virtual address.</span>
<span style="color: darkgreen">/* Query to get the total locked cache size */</span>
<span style="color: blue">int</span> locked_size = HAP_query_total_cachelock();  <span style="color: darkgreen">//If there is no lock requests from other clients then "locked_size" value will be 96KB here.</span>
...
<span style="color: darkgreen">/* 
 * Processing block 
 */</span>
...     
<span style="color: darkgreen">/* Unlock request for locked 64KB memory */</span>
<span style="color: blue">int</span> result = HAP_cache_unlock(vaddr_ptr);   <span style="color: darkgreen">//Returns "0" if unlock successful.</span>
<span style="color: darkgreen">/* Unlock request for locked 32KB memory */</span>
result = HAP_cache_unlock(vaddr_ptr_1); <span style="color: darkgreen">//Returns "0" if unlock successful.</span>
</pre><p>
Example 2: User provides the address of 10KB memory to be locked. After processing requests for unlock.
</p><pre><span style="color: darkgreen">/* Lock request, "buffer_addr" points to virtual address of 10KB memory to be locked */</span>
<span style="color: blue">int</span> result = HAP_cache_lock_addr(buffer_addr, 10*1024); <span style="color: darkgreen">//Returns "0" if lock successful.</span>
...
<span style="color: darkgreen">/* 
 * Processing block 
 */</span>
...
<span style="color: darkgreen">/* Unlock request */</span>        
result = HAP_cache_unlock_addr(buffer_addr);    <span style="color: darkgreen">//Returns "0" if unlock successful.</span>
</pre><p align="center" style="display:block;padding-top: 50px;">
  Copyright &#169; 2018 Qualcomm Technologies Inc. All rights reserved.

</p><a style="display:block;padding-bottom: 700px;"></a></div></div>
</body>
</html>
