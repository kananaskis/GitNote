<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style type="text/css">
table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}
td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}

.smarkdoc {
  margin-left: 42px; margin-right: 42px;
  font-size: 13px;
  font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif;
}

h1, h2, h3 { color: #3c4c6c; }
h1 {
  text-align: center;
  font-size: 200%;
/*    margin-left: -30px; */
  clear: both;
}
h2 {
  font-size: 160%;
  margin: 32px -40px 24px -42px;
  padding: 3px 24px 8px;
  border-bottom: 2px solid #5088c5;
  clear: both;
}
h3 {
  font-size: 130%;
  margin: 20px -4px 10px;
  padding: 4px;
  clear: both;
}
h4 {
  font-size: 110%;
  margin: 2em 0 1em;
}

pre {
  font-size: 90%;
  background-color: #f0f0f4; padding: 6px; border: 1px solid #d0d0ee;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

.pre {
  font-size: 90%;
  padding: 6px;
  background-color: #f0f0f4;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

code {
  font-size: 90%;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

h3 code {
  font-size: 100%;
}

p {
  margin: 0.8em 0;
}
ul, ol {
  margin: 1em 0 1em 3em; padding: 0;
}
div.indent {
  margin: 0 3em;
}

a[href] {
  text-decoration: none;
  color: #2020b0;
}
a[href]:hover {
  border-bottom: 1px dotted #2030d0;
}

/* Smark Users Guide */

.codebox {
  padding: 0 1px;  margin-right:1px;
  border:1px solid #d0d0ee;
  background-color: #f0f0f4;
  font-weight: bold;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* .art .line {  -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.3); } */

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console";
   margin-left: auto; margin-right: auto;
   background-color: white;
   /* border: 1px solid #555; */  /* Useful for non-white pages */
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
.toc {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em;
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}

/* ================ Print ================ */

@media print {

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 3in 0 20px; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em -2em }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}

/* ================  Layout  ================ */
/*
 *  +------------------------+
 *  |         #header        |
 *  +----------+-------------+
 *  | #sidebar |  #content   |
 *  |          |             |
 *  +----------+-------------+
 *
 * CSS padding, border width, and border style (!) affect the actual height
 * (and in turn layout).
 */

#header {
  position: fixed;
  top: 0px;
  height: 32px;
  left: 0px;
  width: 100%;
  padding: 10px 10px 0 0;
}
#sidebar {
  position: fixed;
  top: 42px;
  bottom: 0px;
  left: 0px;
  min-width: 180px;
  overflow: auto;
  border: 1px solid transparent;
  border-width: 0 1px 0 1px;
  padding: 0px 5px 0px 5px;
}
#content {
  position: fixed;
  top: 60px;
  left: 200px;
  bottom: 0px;
  right: 0px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding: 10px 20px;
  padding-top: 0;
}

/* ================  Styles  ================ */


body {
  font-family: "Lucida Grande", Helvetica, Arial, sans-serif;
  font-size: 16px;
}

#header {
  color: #fff;
  background: #555;
  text-align: center;
  font-size: 25px;
}

#sidebar {
  color: #000;
  background: #eee;
  border-right: 1px solid #bbb;
  text-align: left;
  font-size: 12px;
  line-height: 50%;
}

#sidebar h1 {
  margin: 0 0 0 0;
  border-left: 5px solid transparent;
  text-align: left;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}

#sidebar h2 {
  margin: 2px 0 8px 0;
  border-left: 5px solid transparent;
  text-align: center;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}



#content {
  margin: 0;
  font-size: 13px;
  line-height: 160%;
}

#content h1, #content h2 {
  border-bottom: 2px solid;
  font-size: 1.8em;
  font-weight: normal;
  margin: 2.0em 0px 1.3em 0px;
  padding-bottom: 0.6em;
  text-align: left;
}

#content h3 {
  color: #242220;
  font-size: 1.4em;
  font-weight: normal;
  margin: 2em 0px 0.8em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}
#content h4 {
  font-size: 1.2em;
  font-weight: normal;
  margin: 2em 0px 0.5em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}

a[href] {
  color: #05c;
  text-decoration: none;
}

#sidebar a {
  /*text-shadow:  1px 1px 2px #fff, -1px -1px #ddd;*/
  line-height: 40%;
}

pre, code {
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
  font-family: "Monaco", monospace;  font-size: 90%;
  background-color: #f8f8fa;
  border: 1px solid #e4e4ee;
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  border-radius: 2px;
  padding: 1px 0 0 1px;
}

pre {
  padding: 2px 4px;
}

table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}

/* Highlight currently-selected sidebar link */

#sidebar a.thisfile {
  color: #557;
}

/* indentation */

#content {
   padding-left: 60px;
}
#content h1, 
#content h2, 
#content h3, h4 {
    margin-left: -30px;
}

h3 > code {
    font-size: 80%;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV 
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console"; 
   margin-left: auto; margin-right: auto;
   background-color: white;
   border: 1px solid #555;
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
/*
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
*/

.toc {
  column-count: 1; column-gap: 2em;
  -moz-column-count: 1; -moz-column-gap: 2em;
  -webkit-column-count: 1; -webkit-column-gap: 2em; 
   alternate: column-width: 235px; column-rule-width: 5px;
}


.columns {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em; p
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}


/* ================ Print ================ */

@media print {

  #header, #content { position: static; }
  #sidebar { display: none; }

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 1in 0 1in; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em 0 }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}


</style><style type="text/css">
.search { right: 20pt; position: fixed; top: 5pt }

</style><title>VTCM Manager</title>
</head><body>
<div class="smarkdoc"><div id="header">Hexagon SDK 3.4.3</div><div id="sidebar"><top><img src="images/sidebar_top.jpg"></top><script src="scripts/post.js" type="text/javascript"></script><form class="search" id="searchForm"><input id="searchquery" name="q" onkeydown="postFunctionKeydown(event, false)"><input id="searchButton" onclick="postFunction(false)" type="button" value="Search"></form><p>
<a href="index.html">Quick start</a>
</p><hr>
<p>
<a href="feature_matrix.html">Feature Matrix</a>
</p><hr>
<p>
<a href="hexagon_architecture.html">Hexagon Architecture</a>
</p><hr>
<p>
<a href="images/Hexagon_Document_Bundle.pdf#page=2881">Hexagon Compiler/Linker</a>
</p><hr>
<p>
<a href="hexagon_libraries.html">Hexagon Standard Libraries</a>
</p><hr>
<p>
<a href="images/80-VB419-178_QuRT_User_Guide.pdf">Hexagon RTOS</a>
</p><hr>
<p>
<a href="images/80-VB419-108_Hexagon_DSP_User_Guide.pdf">Hexagon DSP Programming</a>
</p><hr>
<h3>
<a name="Platforms"></a>Platforms
</h3><p>
<a href="Platforms_HLOS.html">HLOS</a>
</p><p>
<a href="Platforms_Simulator.html">Simulator</a>
</p><p>
<a href="Platforms_Target.html">Target</a>
</p><hr>
<h3>
<a name="Environments"></a>Environments
</h3><p>
<a href="Environments_Build%20System.html">Build System</a>
</p><p>
<a href="Environments_Build%20System%20Porting.html">Build System Porting</a>
</p><p>
<a href="Environments_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="ArchitectureOverview"></a>ArchitectureOverview
</h3><p>
<a href="HVX/ArchitectureOverview.html">HVX</a>
</p><hr>
<h3>
<a name="Applications"></a>Applications
</h3><p>
<a href="Audio/Applications.html">Audio</a>
</p><p>
<a href="Camera%20streaming/Applications.html">Camera streaming</a>
</p><p>
<a href="Applications_Compute%20offload.html">Compute offload</a>
</p><p>
<a href="FastCV/Applications_Computer%20Vision.html">Computer Vision</a>
</p><p>
<a href="Neural%20Networks/Applications.html">Neural Networks</a>
</p><p>
<a href="Voice/Applications.html">Voice</a>
</p><hr>
<h3>
<a name="APIs"></a>APIs
</h3><p>
<a href="APIs_Async%20Message%20Queue.html">Async Message Queue</a>
</p><p>
<a href="APIs_DSP%20Clk%20&amp;%20Rsrc%20Mgmt.html">DSP Clk &amp; Rsrc Mgmt</a>
</p><p>
<a href="APIs_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="APIs_FastRPC.html">FastRPC</a>
</p><hr>
<h3>
<a name="Examples"></a>Examples
</h3><p>
<a href="Audio/Examples.html">Audio</a>
</p><p>
<a href="Camera%20streaming/Examples.html">Camera streaming</a>
</p><p>
<a href="Examples_Common.html">Common</a>
</p><p>
<a href="Examples_ComputeHVX.html">ComputeHVX</a>
</p><p>
<a href="Examples_GeneralOverview.html">GeneralOverview</a>
</p><p>
<a href="Neural%20Networks/Examples.html">Neural Networks</a>
</p><hr>
<h3>
<a name="Testing"></a>Testing
</h3><p>
<a href="CAPIv2/Testing_CAPIv2%20Unit%20Tests.html">CAPIv2 Unit Tests</a>
</p><p>
<a href="Testing_Eclipse%20Unit%20Tests.html">Eclipse Unit Tests</a>
</p><hr>
<h3>
<a name="Debugging"></a>Debugging
</h3><p>
<a href="Debugging_Connect%20to%20Device.html">Connect to Device</a>
</p><p>
<a href="Debugging_Exceptions.html">Exceptions</a>
</p><p>
<a href="Debugging_Message%20Logging.html">Message Logging</a>
</p><p>
<a href="Debugging_Simulator.html">Simulator</a>
</p><p>
<a href="Debugging_Target.html">Target</a>
</p><hr>
<h3>
<a name="Tools"></a>Tools
</h3><p>
<a href="Tools_Hexagon%20Tools%208.3.html">Hexagon Tools 8.3</a>
</p><p>
<a href="Tools_IDL%20Compiler.html">IDL Compiler</a>
</p><p>
<a href="Tools_On%20Target%20Profiling.html">On Target Profiling</a>
</p><p>
<a href="Tools_Scripts.html">Scripts</a>
</p><p>
<a href="Tools_Signing.html">Signing</a>
</p><p>
<a href="Tools_UserGuides.html">UserGuides</a>
</p><p>
<a href="Tools_Utilities.html">Utilities</a>
</p><hr>
<h3>
<a name="FAQ"></a>FAQ
</h3><p>
<a href="FAQ_Common.html">Common</a>
</p><p>
<a href="FAQ_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="FAQ_FastRPC.html">FastRPC</a>
</p><p>
<a href="FAQ_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="Dependencies"></a>Dependencies
</h3><p>
<a href="Dependencies_Common.html">Common</a>
</p><hr>
<h3>
<a name="Release%20Notes"></a>Release Notes
</h3><p>
<a href="Release%20Notes_Common.html">Common</a>
</p><hr>
<h3>
<a name="Support"></a>Support
</h3><p>
<a href="Support_Contact.html">Contact</a>
</p><center><img src="images/sidebar_bot.jpg"></center></div><div id="content"><a name="_top_" style="display:block;"></a><h1>
<a name="VTCM%20Manager"></a>VTCM Manager
</h1><div class="toc"><div class="tocLevel"><a href="#Supported%20targets">Supported targets</a></div><div class="tocLevel"><a href="#Overview">Overview</a><div class="tocLevel"><a href="#HAP_request_VTCM">HAP_request_VTCM</a></div><div class="tocLevel"><a href="#HAP_release_VTCM">HAP_release_VTCM</a><div class="tocLevel"><a href="#Example:">Example:</a></div></div><div class="tocLevel"><a href="#HAP_query_avail_VTCM">HAP_query_avail_VTCM</a><div class="tocLevel"><a href="#_Example:">Example:</a></div></div><div class="tocLevel"><a href="#HAP_query_total_VTCM">HAP_query_total_VTCM</a><div class="tocLevel"><a href="#__Example:">Example:</a></div></div><div class="tocLevel"><a href="#HAP_request_async_VTCM">HAP_request_async_VTCM</a><div class="tocLevel"><a href="#___Example:">Example:</a></div></div></div><div class="tocLevel"><a href="#Usage">Usage</a><div class="tocLevel"><a href="#Example-1">Example-1</a></div><div class="tocLevel"><a href="#Example-2">Example-2</a></div></div></div><h2>
<a name="Supported%20targets"></a>Supported targets
</h2><p>
SDM845 (CDSP), SDM710 (CDSP), QCS605 (CDSP), SM8150 (CDSP), SM6150 (CDSP), QCS405 (CDSP)
</p><h2>
<a name="Overview"></a>Overview
</h2><p>
VTCM (Vector TCM) of 256 Kilo-Bytes is available on supported targets with CDSP. HVX scatter and gather instructions (added in v65 architecture) operate on memory from VTCM. VTCM Manager exposes APIs to allocate, free and query availability of VTCM using the following header file:
</p><p>
<code>&lt;Hexagon SDK&gt;/incs/HAP_vtcm_mgr.h</code>.
</p><h3>
<a name="HAP_request_VTCM"></a>HAP_request_VTCM
</h3><p>
API to request VTCM memory of desired size and single page requirement.
</p><table><tr><th><p>
API
</p></th><td colspan="3"><p>
void* <b>HAP_request_VTCM</b> (unsigned int <b>size</b>, unsigned int <b>single_page_flag</b>)
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="3"><p>
Returns a void pointer to the allocated memory region on success. Returns 0 on failure
</p></td></tr><tr><th rowspan="2"><p>
Parameters
</p></th><td><p>
<b>size</b>
</p></td><td colspan="2"><p>
Size of the request in bytes.
</p><p>
if (<b>single_page_flag</b> == 0): The size will be aligned to 4KB.
</p><p>
if (<b>single_page_flag</b> == 1): The size will be aligned to the closest possible page size i.e, 4KB / 16KB / 64KB / 256KB.
</p></td></tr><tr><td colspan="2"><p>
<b>single_page_flag</b>
</p></td><td><p>
single page requirement for this allocation. 1 for single page requests, 0 otherwise. Single page requests are mandatory for scatter/gather operations as they require to be contained within a single page of memory
</p><p>
(The memory region used by scatter/gather instructions must reside in VTCM and cannot cross a page boundary).
</p></td></tr></table><h3>
<a name="HAP_release_VTCM"></a>HAP_release_VTCM
</h3><p>
API to release a successful request for VTCM memory by providing the pointer to the previously allocated VTCM block.
</p><table><tr><th><p>
API
</p></th><td colspan="2"><p>
int <b>HAP_release_VTCM</b> (void* <b>pVA</b>)
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="2"><p>
Returns 0 on success. Non-zero for failures.
</p></td></tr><tr><th><p>
Parameters
</p></th><td><p>
<b>pVA</b>
</p></td><td><p>
pointer returned by the corresponding VTCM request call.
</p></td></tr></table><h4>
<a name="Example:"></a>Example:
</h4><pre><span style="color: darkgreen">// Request for a single page of 4000 bytes</span>
<span style="color: blue">void</span> *pVTCM = HAP_request_VTCM(4000, 1);
<span style="color: blue">if</span> (0 != pVTCM)
{
    <span style="color: darkgreen">// Allocation is successful. Try a release</span>
    <span style="color: blue">int</span> result = HAP_release_VTCM(pVTCM);
    <span style="color: blue">if</span> (0 == result)
    {
        <span style="color: darkgreen">//Release successful</span>
    }
}
</pre><h3>
<a name="HAP_query_avail_VTCM"></a>HAP_query_avail_VTCM
</h3><p>
API to query VTCM allocation status.
</p><table><tr><th><p>
API
</p></th><td colspan="2"><p>
int <b>HAP_query_avail_VTCM</b> (unsigned int* <b>avail_block_size</b>, unsigned int* <b>max_page_size</b>, unsigned int* <b>num_pages</b>)
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="2"><p>
Returns 0 for success and non-zero for failures.
</p></td></tr><tr><th rowspan="3"><p>
Parameters
</p></th><td><p>
<b>avail_block_size</b>
</p></td><td><p>
Pointer to an unsigned int variable. On success (return = 0), if <b>avail_block_size</b> is non-zero, the memory location will contain maximum continguous memory chunk (in bytes) available in VTCM.
</p></td></tr><tr><td><p>
<b>max_page_size</b>
</p></td><td><p>
Pointer to an unsigned int variable. On success (return = 0), if <b>max_page_size</b> is non-zero, the memory location will contain maximum possible page size allocation (in bytes) in available portion of VTCM.
</p></td></tr><tr><td><p>
<b>num_pages</b>
</p></td><td><p>
Pointer to an unsigned int variable. On success (return = 0), if <b>num_pages</b> is non-zero, the memory location will contain number of <b>max_page_size</b> blocks available in VTCM.
</p></td></tr></table><h4>
<a name="_Example:"></a>Example:
</h4><pre><span style="color: blue">unsigned</span> <span style="color: blue">int</span> avail_block_size, max_page_size, num_pages;
<span style="color: blue">if</span> (0 == HAP_query_avail_VTCM(&amp;avail_block_size, &amp;max_page_size, &amp;num_pages))
{
    <span style="color: darkgreen">/* Query successful.
     * Use avail_block_size, max_page_size, num_pages */</span>
}
</pre><h3>
<a name="HAP_query_total_VTCM"></a>HAP_query_total_VTCM
</h3><p>
API to query VTCM size defined on target.
</p><table><tr><th><p>
API
</p></th><td colspan="2"><p>
int <b>HAP_query_total_VTCM</b> (unsigned int* <b>page_size</b>, unsigned int* <b>page_count</b>)
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="2"><p>
Returns 0 for success and non-zero for failures.
</p></td></tr><tr><th rowspan="2"></th><td><p>
<b>page_size</b>
</p></td><td><p>
Pointer to an unsigned int variable. On success (return = 0), if <b>page_size</b> is non-zero, the memory location will contain maximum possible page size (in bytes) allocation in VTCM.
</p></td></tr><tr><td><p>
<b>page_count</b>
</p></td><td><p>
Pointer to an unsigned int variable. On success (return = 0), if <b>page_count</b> is non-zero, the memory location will contain number of <b>page_size</b> blocks in VTCM.
</p></td></tr></table><h4>
<a name="__Example:"></a>Example:
</h4><pre><span style="color: blue">unsigned</span> <span style="color: blue">int</span> page_size, page_count;
<span style="color: blue">if</span> (0 == HAP_query_total_VTCM(&amp;page_size, &amp;page_count))
{
    <span style="color: darkgreen">/* Query successful.
     * For SDM845/SDM670 CDSP:
     *      page_size will be 256 * 1024.
     *      page_count will be 1.
     * VTCM memory defined for this chipset (256 KB) */</span>
    <span style="color: blue">unsigned</span> <span style="color: blue">int</span> total_vtcm = page_size * page_count;
}
</pre><h3>
<a name="HAP_request_async_VTCM"></a>HAP_request_async_VTCM
</h3><p>
API to request VTCM memory of desired size and single page requirement with a timeout option. This API can be used to wait till the provided time out for the request to be fulfilled. The calling thread will be suspended till the requested VTCM memory is available or till the timeout, which ever happens first.
</p><p>
<b>NOTE:</b> Possibility of a dead lock when calling this API in below scenario:
</p><ul class="indent" type="circle">
<li>
<p>
The same thread holding a part of or entire VTCM memory prior to this call.
</p>
</li>
</ul><p>
<b>This API is not supported from SecurePD and CPZ processes</b>
</p><table><tr><th><p>
API
</p></th><td colspan="3"><p>
void* <b>HAP_request_async_VTCM</b> (unsigned int <b>size</b>,
</p><div class="indent"><p>
unsigned int <b>single_page_flag</b>, unsigned int <b>timeout_us</b>)
</p></div></td></tr><tr><th><p>
Return
</p></th><td colspan="3"><p>
Returns a void pointer to the allocated memory region on success. Returns 0 on failure
</p></td></tr><tr><th rowspan="3"><p>
Parameters
</p></th><td><p>
<b>size</b>
</p></td><td colspan="2"><p>
Size of the request in bytes.
</p><p>
if (<b>single_page_flag</b> == 0): The size will be aligned to 4KB.
</p><p>
if (<b>single_page_flag</b> == 1): The size will be aligned to the closest possible page size i.e, 4KB / 16KB / 64KB / 256KB.
</p></td></tr><tr><td colspan="2"><p>
<b>single_page_flag</b>
</p></td><td><p>
single page requirement for this allocation. 1 for single page requests, 0 otherwise. Single page requests are mandatory for scatter/gather operations as they require to be contained within a single page of memory
</p><p>
(The memory region used by scatter/gather instructions must reside in VTCM and cannot cross a page boundary).
</p></td></tr><tr><td colspan="2"><p>
<b>timeout_us</b>
</p></td><td><p>
Timeout in micro seconds. If the request is readily available, return success with a void pointer. If request cannot be served, waits for the available VTCM memory till the provided timeout or returns failure on timeout. Value should be greater than 200 (micro-seconds) for the timeout implementation to work, treated as <b>HAP_request_VTCM</b> otherwise.
</p></td></tr></table><h4>
<a name="___Example:"></a>Example:
</h4><pre><span style="color: darkgreen">/* Request for a single page of 256 * 1024  bytes with
 * timeout set to 5 milli-seconds */</span>
<span style="color: blue">void</span> *pVTCM = HAP_request_async_VTCM(256 * 1024, 1, 5000);
<span style="color: blue">if</span> (0 != pVTCM)
{
    <span style="color: darkgreen">// Allocation is successful. Try a release</span>
    <span style="color: blue">int</span> result = HAP_release_VTCM(pVTCM);
    <span style="color: blue">if</span> (0 == result)
    {
        <span style="color: darkgreen">//Release successful</span>
    }
}
</pre><h2>
<a name="Usage"></a>Usage
</h2><h3>
<a name="Example-1"></a>Example-1
</h3><pre><span style="color: darkgreen">/* Supported page sizes : 4KB, 16KB, 64KB, 256KB, 1MB, 4MB, 16MB.
 *
 * Query for the VTCM defined for this chipset and try allocate
 * all of VTCM possible under single page */</span>
<span style="color: blue">unsigned</span> <span style="color: blue">int</span> page_size, page_count;
<span style="color: blue">if</span> (0 != HAP_query_total_VTCM(&amp;page_size, &amp;page_count))
{
    <span style="color: darkgreen">/* Query failed, return */</span>
    <span style="color: blue">return</span>;
}
<span style="color: darkgreen">/* Query successful.
 * For SDM845/SDM670 CDSP:
 *      page_size will be 256 * 1024.
 *      page_count will be 1.
 * VTCM memory defined for this chipset (256 KB) */</span>
<span style="color: blue">void</span> *pVTCM = HAP_request_VTCM(page_size, 1);
<span style="color: blue">if</span> (0 != pVTCM)
{
    <span style="color: darkgreen">/* Allocation is successful
     * Use VTCM */</span>
    ...
    <span style="color: darkgreen">/* Done using VTCM, release */</span>
    HAP_release_VTCM(pVTCM);
}
<span style="color: blue">else</span>
{
    <span style="color: darkgreen">/* page_size page is not available. 
     * Try a query to get the availability of VTCM */</span>
    <span style="color: blue">unsigned</span> <span style="color: blue">int</span> avail_block_size, max_page_size, num_pages;
    <span style="color: blue">if</span> (0 == HAP_query_avail_VTCM(&amp;avail_block_size, &amp;max_page_size, &amp;num_pages))
    {
        <span style="color: darkgreen">/* Query successful.
         * Read avail_block_size, max_page_size, num_pages */</span>
        FARF(ALWAYS, <span style="color: darkred">"Maximum single page allocation possible in VTCM (in bytes): %d ;number of such pages available: %d"</span>, max_page_size, num_pages);
        FARF(ALWAYS, <span style="color: darkred">"Maximum allocation possible in VTCM (in bytes): %d"</span>, avail_block_size);
        <span style="color: blue">if</span> (0 &lt; max_page_size)
        {
            <span style="color: darkgreen">/* 256KB page is not available. This is the maximum memory size
             * possible to be allocated as a single page */</span>
            pVTCM = HAP_request_VTCM(max_page_size, 1);
            <span style="color: blue">if</span> (0 != pVTCM)
            {
                <span style="color: darkgreen">/* Allocation is successful.
                 * Allocation size is: max_page_size bytes */</span>
                 ...

                 <span style="color: darkgreen">/* Release VTCM allocation once done */</span>
                 HAP_release_VTCM(pVTCM);
            }
        }
    }
}
</pre><h3>
<a name="Example-2"></a>Example-2
</h3><pre><span style="color: darkgreen">/* Try a 8000 bytes single page VTCM request */</span>
<span style="color: blue">void</span> *pVTCM = HAP_request_VTCM(8000, 1);
<span style="color: blue">if</span> (0 != pVTCM)
{
    <span style="color: darkgreen">/* Allocation is successful.
     * The nearest possible page for a 8000 bytes request
     * is 16KB (16 * 1024 bytes). VTCM manager would have 
     * allocated a 16KB memory section for this allocation. */</span>

     ...

     <span style="color: darkgreen">/* Release VTCM once done */</span>
     HAP_release_VTCM(pVTCM);
}
<span style="color: blue">else</span>
{
    <span style="color: darkgreen">/* A single page for 8000 bytes allocation failed.
     * Query to check availability */</span>
    <span style="color: blue">unsigned</span> <span style="color: blue">int</span> avail_block_size, max_page_size, num_pages;
    <span style="color: blue">if</span> (0 == HAP_query_avail_VTCM(&amp;avail_block_size, &amp;max_page_size, &amp;num_pages))
    {
        <span style="color: darkgreen">/* Query successful.
         * Check maximum allocation possible in VTCM */</span>
        FARF(ALWAYS, <span style="color: darkred">"Maximum single page allocation possible in VTCM (in bytes): %d ;number of such pages available: %d"</span>, max_page_size, num_pages);
        FARF(ALWAYS, <span style="color: darkred">"Maximum allocation possible in VTCM (in bytes): %d"</span>, avail_block_size);
        <span style="color: blue">if</span> ( (8000 &gt; max_page_size) &amp;&amp; (8000 &lt; avail_block_size) )
        {
            <span style="color: darkgreen">/* 8000 bytes can't be allocated in a single page, but can be allocated
             * without the single page requirement (will be aligned to nearest 4KB multiple i.e, 8192 bytes) */</span>
            pVTCM = HAP_request_VTCM(8000, 0);
            <span style="color: blue">if</span> (0 != pVTCM)
            {
                <span style="color: darkgreen">/* Allocation is successful. 
                 * Use Allocated block of VTCM */</span>
                ...
                <span style="color: darkgreen">/* Once done, release VTCM block */</span>
                HAP_release_VTCM(pVTCM);
            }
        }
    }
}</pre><p align="center" style="display:block;padding-top: 50px;">
  Copyright &#169; 2018 Qualcomm Technologies Inc. All rights reserved.

</p><a style="display:block;padding-bottom: 700px;"></a></div></div>
</body>
</html>
