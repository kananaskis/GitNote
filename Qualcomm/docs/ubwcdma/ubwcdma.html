<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style type="text/css">
table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}
td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}

.smarkdoc {
  margin-left: 42px; margin-right: 42px;
  font-size: 13px;
  font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif;
}

h1, h2, h3 { color: #3c4c6c; }
h1 {
  text-align: center;
  font-size: 200%;
/*    margin-left: -30px; */
  clear: both;
}
h2 {
  font-size: 160%;
  margin: 32px -40px 24px -42px;
  padding: 3px 24px 8px;
  border-bottom: 2px solid #5088c5;
  clear: both;
}
h3 {
  font-size: 130%;
  margin: 20px -4px 10px;
  padding: 4px;
  clear: both;
}
h4 {
  font-size: 110%;
  margin: 2em 0 1em;
}

pre {
  font-size: 90%;
  background-color: #f0f0f4; padding: 6px; border: 1px solid #d0d0ee;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

.pre {
  font-size: 90%;
  padding: 6px;
  background-color: #f0f0f4;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

code {
  font-size: 90%;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

h3 code {
  font-size: 100%;
}

p {
  margin: 0.8em 0;
}
ul, ol {
  margin: 1em 0 1em 3em; padding: 0;
}
div.indent {
  margin: 0 3em;
}

a[href] {
  text-decoration: none;
  color: #2020b0;
}
a[href]:hover {
  border-bottom: 1px dotted #2030d0;
}

/* Smark Users Guide */

.codebox {
  padding: 0 1px;  margin-right:1px;
  border:1px solid #d0d0ee;
  background-color: #f0f0f4;
  font-weight: bold;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* .art .line {  -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.3); } */

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console";
   margin-left: auto; margin-right: auto;
   background-color: white;
   /* border: 1px solid #555; */  /* Useful for non-white pages */
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
.toc {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em;
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}

/* ================ Print ================ */

@media print {

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 3in 0 20px; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em -2em }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}

/* ================  Layout  ================ */
/*
 *  +------------------------+
 *  |         #header        |
 *  +----------+-------------+
 *  | #sidebar |  #content   |
 *  |          |             |
 *  +----------+-------------+
 *
 * CSS padding, border width, and border style (!) affect the actual height
 * (and in turn layout).
 */

#header {
  position: fixed;
  top: 0px;
  height: 32px;
  left: 0px;
  width: 100%;
  padding: 10px 10px 0 0;
}
#sidebar {
  position: fixed;
  top: 42px;
  bottom: 0px;
  left: 0px;
  min-width: 180px;
  overflow: auto;
  border: 1px solid transparent;
  border-width: 0 1px 0 1px;
  padding: 0px 5px 0px 5px;
}
#content {
  position: fixed;
  top: 60px;
  left: 200px;
  bottom: 0px;
  right: 0px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding: 10px 20px;
  padding-top: 0;
}

/* ================  Styles  ================ */


body {
  font-family: "Lucida Grande", Helvetica, Arial, sans-serif;
  font-size: 16px;
}

#header {
  color: #fff;
  background: #555;
  text-align: center;
  font-size: 25px;
}

#sidebar {
  color: #000;
  background: #eee;
  border-right: 1px solid #bbb;
  text-align: left;
  font-size: 12px;
  line-height: 50%;
}

#sidebar h1 {
  margin: 0 0 0 0;
  border-left: 5px solid transparent;
  text-align: left;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}

#sidebar h2 {
  margin: 2px 0 8px 0;
  border-left: 5px solid transparent;
  text-align: center;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}



#content {
  margin: 0;
  font-size: 13px;
  line-height: 160%;
}

#content h1, #content h2 {
  border-bottom: 2px solid;
  font-size: 1.8em;
  font-weight: normal;
  margin: 2.0em 0px 1.3em 0px;
  padding-bottom: 0.6em;
  text-align: left;
}

#content h3 {
  color: #242220;
  font-size: 1.4em;
  font-weight: normal;
  margin: 2em 0px 0.8em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}
#content h4 {
  font-size: 1.2em;
  font-weight: normal;
  margin: 2em 0px 0.5em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}

a[href] {
  color: #05c;
  text-decoration: none;
}

#sidebar a {
  /*text-shadow:  1px 1px 2px #fff, -1px -1px #ddd;*/
  line-height: 40%;
}

pre, code {
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
  font-family: "Monaco", monospace;  font-size: 90%;
  background-color: #f8f8fa;
  border: 1px solid #e4e4ee;
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  border-radius: 2px;
  padding: 1px 0 0 1px;
}

pre {
  padding: 2px 4px;
}

table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}

/* Highlight currently-selected sidebar link */

#sidebar a.thisfile {
  color: #557;
}

/* indentation */

#content {
   padding-left: 60px;
}
#content h1, 
#content h2, 
#content h3, h4 {
    margin-left: -30px;
}

h3 > code {
    font-size: 80%;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV 
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console"; 
   margin-left: auto; margin-right: auto;
   background-color: white;
   border: 1px solid #555;
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
/*
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
*/

.toc {
  column-count: 1; column-gap: 2em;
  -moz-column-count: 1; -moz-column-gap: 2em;
  -webkit-column-count: 1; -webkit-column-gap: 2em; 
   alternate: column-width: 235px; column-rule-width: 5px;
}


.columns {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em; p
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}


/* ================ Print ================ */

@media print {

  #header, #content { position: static; }
  #sidebar { display: none; }

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 1in 0 1in; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em 0 }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}


</style><style type="text/css">
.search { right: 20pt; position: fixed; top: 5pt }

</style><title>UBWCDMA User Manual</title>
</head><body>
<div class="smarkdoc"><div id="header">Hexagon SDK 3.4.3</div><div id="sidebar"><top><img src="../images/sidebar_top.jpg"></top><script src="../scripts/post.js" type="text/javascript"></script><form class="search" id="searchForm"><input id="searchquery" name="q" onkeydown="postFunctionKeydown(event, true)"><input id="searchButton" onclick="postFunction(true)" type="button" value="Search"></form><p>
<a href="../index.html">Quick start</a>
</p><hr>
<p>
<a href="../feature_matrix.html">Feature Matrix</a>
</p><hr>
<p>
<a href="../hexagon_architecture.html">Hexagon Architecture</a>
</p><hr>
<p>
<a href="../images/Hexagon_Document_Bundle.pdf#page=2881">Hexagon Compiler/Linker</a>
</p><hr>
<p>
<a href="../hexagon_libraries.html">Hexagon Standard Libraries</a>
</p><hr>
<p>
<a href="../images/80-VB419-178_QuRT_User_Guide.pdf">Hexagon RTOS</a>
</p><hr>
<p>
<a href="../images/80-VB419-108_Hexagon_DSP_User_Guide.pdf">Hexagon DSP Programming</a>
</p><hr>
<h3>
<a name="Platforms"></a>Platforms
</h3><p>
<a href="../Platforms_HLOS.html">HLOS</a>
</p><p>
<a href="../Platforms_Simulator.html">Simulator</a>
</p><p>
<a href="../Platforms_Target.html">Target</a>
</p><hr>
<h3>
<a name="Environments"></a>Environments
</h3><p>
<a href="../Environments_Build%20System.html">Build System</a>
</p><p>
<a href="../Environments_Build%20System%20Porting.html">Build System Porting</a>
</p><p>
<a href="../Environments_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="ArchitectureOverview"></a>ArchitectureOverview
</h3><p>
<a href="../HVX/ArchitectureOverview.html">HVX</a>
</p><hr>
<h3>
<a name="Applications"></a>Applications
</h3><p>
<a href="../Audio/Applications.html">Audio</a>
</p><p>
<a href="../Camera%20streaming/Applications.html">Camera streaming</a>
</p><p>
<a href="../Applications_Compute%20offload.html">Compute offload</a>
</p><p>
<a href="../FastCV/Applications_Computer%20Vision.html">Computer Vision</a>
</p><p>
<a href="../Neural%20Networks/Applications.html">Neural Networks</a>
</p><p>
<a href="../Voice/Applications.html">Voice</a>
</p><hr>
<h3>
<a name="APIs"></a>APIs
</h3><p>
<a href="../APIs_Async%20Message%20Queue.html">Async Message Queue</a>
</p><p>
<a href="../APIs_DSP%20Clk%20&amp;%20Rsrc%20Mgmt.html">DSP Clk &amp; Rsrc Mgmt</a>
</p><p>
<a href="../APIs_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="../APIs_FastRPC.html">FastRPC</a>
</p><hr>
<h3>
<a name="Examples"></a>Examples
</h3><p>
<a href="../Audio/Examples.html">Audio</a>
</p><p>
<a href="../Camera%20streaming/Examples.html">Camera streaming</a>
</p><p>
<a href="../Examples_Common.html">Common</a>
</p><p>
<a href="../Examples_ComputeHVX.html">ComputeHVX</a>
</p><p>
<a href="../Examples_GeneralOverview.html">GeneralOverview</a>
</p><p>
<a href="../Neural%20Networks/Examples.html">Neural Networks</a>
</p><hr>
<h3>
<a name="Testing"></a>Testing
</h3><p>
<a href="../CAPIv2/Testing_CAPIv2%20Unit%20Tests.html">CAPIv2 Unit Tests</a>
</p><p>
<a href="../Testing_Eclipse%20Unit%20Tests.html">Eclipse Unit Tests</a>
</p><hr>
<h3>
<a name="Debugging"></a>Debugging
</h3><p>
<a href="../Debugging_Connect%20to%20Device.html">Connect to Device</a>
</p><p>
<a href="../Debugging_Exceptions.html">Exceptions</a>
</p><p>
<a href="../Debugging_Message%20Logging.html">Message Logging</a>
</p><p>
<a href="../Debugging_Simulator.html">Simulator</a>
</p><p>
<a href="../Debugging_Target.html">Target</a>
</p><hr>
<h3>
<a name="Tools"></a>Tools
</h3><p>
<a href="../Tools_Hexagon%20Tools%208.3.html">Hexagon Tools 8.3</a>
</p><p>
<a href="../Tools_IDL%20Compiler.html">IDL Compiler</a>
</p><p>
<a href="../Tools_On%20Target%20Profiling.html">On Target Profiling</a>
</p><p>
<a href="../Tools_Scripts.html">Scripts</a>
</p><p>
<a href="../Tools_Signing.html">Signing</a>
</p><p>
<a href="../Tools_UserGuides.html">UserGuides</a>
</p><p>
<a href="../Tools_Utilities.html">Utilities</a>
</p><hr>
<h3>
<a name="FAQ"></a>FAQ
</h3><p>
<a href="../FAQ_Common.html">Common</a>
</p><p>
<a href="../FAQ_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="../FAQ_FastRPC.html">FastRPC</a>
</p><p>
<a href="../FAQ_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="Dependencies"></a>Dependencies
</h3><p>
<a href="../Dependencies_Common.html">Common</a>
</p><hr>
<h3>
<a name="Release%20Notes"></a>Release Notes
</h3><p>
<a href="../Release%20Notes_Common.html">Common</a>
</p><hr>
<h3>
<a name="Support"></a>Support
</h3><p>
<a href="../Support_Contact.html">Contact</a>
</p><center><img src="../images/sidebar_bot.jpg"></center></div><div id="content"><a name="_top_" style="display:block;"></a><h1>
<a name="UBWCDMA%20User%20Manual"></a>UBWCDMA User Manual
</h1><h2>
<a name="Introduction"></a><a name="introduction">Introduction</a>
</h2><h3>
<a name="Purpose"></a>Purpose
</h3><p>
The purpose of this document is to provide an overview of the operation of the UBWCDMA and a description of its driver API. The intent of the UBWCDMA IP is to provide a DMA block for the Q6DSP design that is capable of accessing UBWC frames in DDR and present them to the Q6DSP as linear frames. In addition, UBWCDMA IP is also capable of performing Q6DSP DMA transactions for linear frames in DDR.
</p><h3>
<a name="Acronyms"></a>Acronyms
</h3><table><tr><th><p>
Acronyms
</p></th><th><p>
Definition
</p></th></tr><tr><td><p>
UBWCDMA
</p></td><td><p>
UBWC Direct Memory Access
</p></td></tr><tr><td><p>
UBWC
</p></td><td><p>
Universal Bandwidth Compression
</p></td></tr><tr><td><p>
DMA
</p></td><td><p>
Direct Memory Access
</p></td></tr><tr><td><p>
VAPSS
</p></td><td><p>
Video Analytics Processor Sub-system
</p></td></tr><tr><td><p>
TCM
</p></td><td><p>
Tightly coupled memory (Inside Q6DSP)
</p></td></tr><tr><td><p>
ROI
</p></td><td><p>
Region of interest
</p></td></tr><tr><td><p>
Bpp
</p></td><td><p>
Bytes per pixel
</p></td></tr></table><h2>
<a name="Features"></a><a name="features">Features</a>
</h2><h3>
<a name="Main%20Features"></a>Main Features
</h3><p>
UBWCDMA IP provides DMA services to the Q6DSP module that enables it to access UBWC frames. The purpose of the UBWCDMA design is to perform translation between UBWC frames stored in DDR and linear frames stored in Q6DSP local memory (TCM implemented as locked L2 cache). However, UBWCMA is also capable of performing DMA for non-UBWC (linear) frames as shown in the list below.
</p><p>
A DMA session provides the following services to Q6DSP:
</p><ol type="1">
<li>
<p>
Read an ROI of a UBWC frame in DDR and store it in Q6DSP local memory in linear format. In this use case, Q6DSP issues a sequence of requests to read an ROI (Region of Interest) in a UBWC frame in DDR and stores the received ROI inside its local memory. Q6DSP performs the required data processing on the ROI, then moves on to the next ROI within the frame until the whole frame is processed.
</p>
</li><li>
<p>
Write an ROI of a linear frame stored in Q6DSP local memory into a UBWC frame in DDR. In this case, Q6DSP creates an ROI of a linear frame, stores it in its local memory, and issues a request to UBWCDMA to write the ROI into a UBWC frame in DDR. This process is repeated until the whole output UBWC frame is written in DDR. Typically, an ROI in this case is produced by processing an input ROI obtained in case number 1 above.
</p>
</li><li>
<p>
Read an ROI of a linear frame in DDR and store it in Q6DSP local memory also in linear format. In this case, Q6DSP issues a sequence of requests to read an ROI (Region of Interest) in a linear frame in DDR and stores the received ROI inside its local memory also in linear format. Q6DSP performs the required data processing on the ROI, then moves on to the next ROI within the frame until the whole frame is processed.
</p>
</li><li>
<p>
Write an ROI of a linear frame stored in Q6DSP local memory into a linear frame in DDR. In this case, Q6DSP creates an ROI of a linear frame, stores it in its local memory, and issues a request to UBWCDMA to write the ROI into a linear frame in DDR. This process is repeated until the whole output UBWC frame is written in DDR. Typically, an ROI in this case is produced by processing an input ROI obtained in case numbers 1 or 3 above.
</p>
</li><li>
<p>
On DDR reads of the TP10 format, UBWCDMA pads each 10 bit pixel to 16 bits (zero padding on 6 LSB bits) before writing to Q6DSP local memory. On DDR write operations of the TP10 format, UBWCDMA reads the pixels from Q6DSP local memory and removes the 16 bit alignment padding before writing into DDR.
</p>
</li><li>
<p>
On DDR reads of the NV12 format, UBWCDMA optionally pads each 8 bit pixel to 16 bits (zero padding on 8 LSB bits) before writing to Q6DSP local memory. On DDR write operations of the NV12 format, UBWCDMA reads the pixels from Q6DSP local memory and removes the 16 bit alignment padding before writing into DDR.
</p>
</li>
</ol><p>
Notice that combining features 1 and 4 above provides a service that converts a UBWC frame into a linear frame. Combining features 3 and 2 provides a service that converts a linear frame into a UBWC frame.
</p><p>
There can be up to 8 DMA sessions running concurrently. A DSP process or thread must first issue a request to UBWCDMA driver to allocate a free DMA engine before it can start a DMA session.
</p><h2>
<a name="UBWCDMA%20Formats"></a><a name="ubwcdma_formats">UBWCDMA Formats</a>
</h2><p>
The UBWCMDA supports the NV12, P010, and NV124R formats in linear and UBWC modes as well as the TP10 format in UBWC mode. A description of each format is provided below.
</p><h3>
<a name="NV12"></a>NV12
</h3><p>
The NV12 format is a 4:2:0 semi-planar YUV format. Each of the Y, U and V components are stored in 1 byte. Since the format is semi-planar it is split into a luminance part (NV12 Y) and a chrominance part (NV12 UV) which are contiguous in memory. The definition of a pixel differs in each plane, in the luminance plane there is 1 byte for each Y pixel. In the chrominance plane, there are 2 bytes per pixel, one for the U component and the other for the V component. Since the format is 4:2:0, the UV components are subsampled in both the vertical and horizontal directions relative to the Y component. Thus, there is a 2x2 Y pixel block for each UV pixel. Figure 1 is an example of the NV12 format, all cells represent bytes and the thicker borders indicate pixel boundaries.
</p><left><img src="images/ubwcdma_nv12.png"></left><p>
<b>Figure 1: NV12 format</b>
</p><p>
The UBWCDMA separates the NV12 format into the NV12 Y and UV components. Frame and ROI parameters are specified in terms of pixels and not bytes. The convention used in programming the DMA is that the UV parameters are specified in terms of the corresponding frame parameters. Since the UV plane is subsampled, this means that an intent to transfer y UV lines should be expressed to the DMA as an intent to transfer 2*y lines. The same holds true in the x dimension. This is done so that transfers are expressed relative to the frame dimensions as opposed to the individual compnents. The Y component is the same size as the frame and so this automatically holds true for it. This Chroma convention holds for all relevant UV parameters including frame width, height and stride as well as ROI width, height and stride. In the UV plane, each pixel consists of a U and V component packed together. Thus, if the DMA is programmed to transfer 64 Chroma pixels in the x dimension, it will actually transfer only 32 such pixels where each pixel is a UV pair. If it is programmed to transfer 64 Chroma lines, it will only transfer 32 lines.
</p><h4>
<a name="NV12%20Padded"></a>NV12 Padded
</h4><p>
The UBWCDMA can pad the NV12 format prior to writing the result to the TCM. Additionally, the padding can be stripped off before writing the result back to DDR. Padding is accomplished by adding 8 zero bits to LSB of each pixel in the Y plane and 8 zero bits to the LSB of each pixel component (U and V) in the UV plane. Padding has no effect from a frame size or ROI point of view. It does however change the TCM alignment constraints in linear mode. Since each pixel holds double the number of bits, and addresses in TCM must be pixel aligned, the necessary alignment of the Y component becomes 2 bytes and that of the UV component becomes 4 bytes. UBWC TCM constraints are unchanged.
</p><h3>
<a name="NV12-4R"></a>NV12-4R
</h3><p>
NV12-4R linear is identical to the NV12 linear format. However, NV12-4R UBWC is compressed differently from NV12 UBWC. From an application point of view both NV12 and NV12-4R pixels are treated the same in TCM. It is only important to program the UBWCDMA distinctively for these two formats so that their decoding and encoding are handled appropriately.
</p><h3>
<a name="P010"></a>P010
</h3><p>
The P010 format is a padded 4:2:0 semi-planar YUV format. Each of the YUV components is 10 bits in this format as opposed to 8 bits in the NV12 formats. Each of the 10 bits is padded to 16 bits and packed into the frame. An example of this frame is shown in Figure 2, the dark cells represent the zero pading bits. There are 2 bytes per pixel in Y frame and 4 bytes per pixel in the UV frame.
</p><left><img src="images/ubwcdma_p010.png"></left><p>
<b>Figure 2: P010 format</b>
</p><h3>
<a name="TP10"></a>TP10
</h3><p>
The TP10 format is a tightly packed 10 bit semi-planar 4:2:0 YUV format. In contrast to the P010 format it does not pad each Y pixel and UV pixel component with 6 bits. Instead it collects 3 components and pads them with extra bits in the MSB. In the Y plane, it collects 3 Y pixels and pads them with 2 bits, while in the UV plane it collects a UVU set or a VUV set and pads with 2 bits. Every pixel consists of 4/3 bytes (4 bytes for every 3 pixels) in the Y plane and 8/3 bytes in the UV plane. It is helpful to imagine the format as consisting of superpixels where in the Y plane each superpixel is 4 bytes and contains 3 components (10*3 + 2 padding bits), while in the UV plane each superpixel is 8 bytes and contains 3 chroma components (3 sets of UV padded with 4 bits in all). The format is shown in Figure 3 where the thicker borders indicate the superpixels. Critically, this format can only have its frame width be a multiple of 3 to ensure an integral number of bytes. Additionally, the width and height must be even as in other formats. This means that width must be a multiple of 6 and the height a multiple of 2.
</p><left><img src="images/ubwcdma_tp10.png"></left><p>
<b>Figure 3: TP10 format</b>
</p><h2>
<a name="Limitations"></a><a name="limitations">Limitations</a>
</h2><ol type="1">
<li>
<p>
UBWC frames in DDR must have start addresses that are 4k aligned, linear frames in DDR do not require this restriction.
</p>
</li><li>
<p>
All programmed {X, Y} coordinates, ROI heights, and widths must be integer multiples of the DMA alignment requirements for the given format. These alignment requirements can be obtained through DMA firmware APIs.
</p>
</li><li>
<p>
TCM restrictions for each format are listed below:
</p>
</li>
</ol><h3>
<a name="NV12%20Linear%20and%20Padded%20Linear"></a>NV12 Linear and Padded Linear
</h3><ol type="1">
<li>
<p>
The start address of the Y plane in TCM must be 32-byte aligned.
</p>
</li><li>
<p>
The start address of the UV plane in TCM must be 32-byte aligned.
</p>
</li><li>
<p>
The stride of the ROI in TCM must at least be the ROI width or can be greater, however, must be 32-byte aligned.
</p>
</li>
</ol><h3>
<a name="NV12-4R%20Linear%20and%20Padded%20Linear"></a>NV12-4R Linear and Padded Linear
</h3><p>
Same as the NV12 Linear requirements listed above.
</p><h3>
<a name="P010%20Linear"></a>P010 Linear
</h3><p>
Same as the NV12 Linear requirements listed above.
</p><h3>
<a name="TP10%20Linear"></a>TP10 Linear
</h3><p>
This is not a supported format by the UBWCDMA.
</p><h3>
<a name="UBWC%20Formats"></a>UBWC Formats
</h3><ol type="1">
<li>
<p>
The start address of the Y plane in TCM must be 256-byte aligned.
</p>
</li><li>
<p>
The start address of the UV plane in TCM must be 256-byte aligned.
</p>
</li><li>
<p>
The stride of the ROI in TCM must be a multiple of 256 pixels.
</p>
</li>
</ol><h2>
<a name="Programming"></a><a name="programming">Programming</a>
</h2><p>
User processes communicate with the DMA hardware via the UBWCDMA FW driver. User processes call the driver API to request a free DMA engine. In response, the UBWCDMA driver determines if there is a free DMA engine, allocates it to the calling user process, and setups the DMA engine by writing the DMA engine's secure setup registers. Each DMA engine operates on a list of commands, known as descriptors which are placed in TCM. This region is allocated by the user process and filled in by the driver. User processes provide the driver with ROI and frame information needed to construct the descriptor list. The user will then instruct the driver to begin the session. The DMA engine starts fetching one descriptor at a time from the list and executing the command before fetching the next descriptor until all descriptors in the list are executed. The user process can communicate with the driver API to determine when the engine has finished processing the descriptors provided to it or block until the driver is done. Once the session is complete, the user process can initiate another session by updating the ROI information and calling the driver API. If the user process has no more sessions to run, it calls the driver API again to release the allocated DMA engine so that other processes may use it. The TCM region allocated for the descriptors should also be released if it will not be reused by another engine.
</p><h2>
<a name="Driver%20API"></a><a name="driver_api">Driver API</a>
</h2><p>
A link to the Driver API can be found at: <i>&lt;HEXAGON_SDK_ROOT&gt;/incs/ubwcdma/dmaWrapper.h</i> . The following illustrates the typical use flow of the DMA driver:
</p><ol type="1">
<li>
<p>
The DMA register space and hardware model is initialized. This is handled in a main.c file for every example. This code is not portable to DMA hardware as initialization is handled there at start up. Instead users should encapsulate their code into an Appmain which is called in the main.c file.
</p>
</li><li>
<p>
An engine is allocated using the <b>hDmaWrapper_AllocDma</b> or <b>hDmaWrapper_AllocDmaSpecifyWaitType</b> functions.
</p>
</li><li>
<p>
Vote for the DMA voltage based on the frequency plan using the HAP_power_Set() or nDmaWrapper_PowerVoting() API's. <i>Note that nDmaWrapper_PowerVoting() API is only available for SM8150 and future targets.</i>
</p>
</li><li>
<p>
The transfer is prepared by specifying frame details, ROIs and DDR addresses. This is done by calling the function <b>nDmaWrapper_Prepare</b>. The user can specify multiple ROIs to transfer for multiple frames. Each provided ROI is a separate transfer for each transaction. The widths and heights provided in the ROIs must be the maximum that the user intends to use throughout the frame transfer (typically widths and heights will be the same throughout except at the boundary).
</p>
</li><li>
<p>
Next, <b>nDmaWrapper_Update</b> is called to update the ROI information for each transfer. Typically, the change is to the next set of image coordinates. The <b>nDmaWrapper_Update</b> function must be given the same number of ROIs as <b>nDmaWrapper_Prepare</b>, and may only change the ROI and TCM addresses; it is not able to change the transfer type, format or the frame to operate on. The ROI widths and heights may only be made smaller than the ROIs given in the prepare function. It is possible to skip ROIs by using a special set of parameters but an ROI must be provided to the update for every ROI provided in the prepare.
</p>
</li><li>
<p>
<b>nDmaWrapper_Move</b> is called to initiate a transfer.
</p>
</li><li>
<p>
<b>nDmaWrapper_Wait</b> is called to block until the current ROIs have all been transferred.
</p>
</li><li>
<p>
Steps 4-6 are repeated until all required ROIs are transferred.
</p>
</li><li>
<p>
<b>nDmaWrapper_FinishFrame</b> is then called to flush DMA buffers. It must be called before calling <b>nDmaWrapper_Prepare</b> again. If a new session with different frame information is required, steps 1-7 are repeated.
</p><ol type="1">
<li>
<p>
<b>nDmaWrapper_FreeDma</b> is called to release all DMA engine resources.
</p>
</li>
</ol>
</li>
</ol><left><img src="images/ubwcdma_api_flow.png"></left><p>
<b>Figure 3: UBWCDMA Driver API flow</b>
</p><h4>
<a name="Application%20Preparation"></a>Application Preparation
</h4><p>
One additional responsibility of the developer is to prepare the application so that the DMA driver can be used:
</p><ol type="1">
<li>
<p>
Determine the L2$ buffer size that will be used by the DMA driver during the application lifetime
</p>
</li><li>
<p>
Allocate and lock the required L2$ buffer space as determined above.
</p>
</li><li>
<p>
<i>DMA Driver API flow as per Figure 3</i>
</p>
</li><li>
<p>
Unlock and deallocate the L2$ buffer
</p>
</li>
</ol><left><img src="images/ubwcdma_app_preparation.png"></left><p>
<b>Figure 4: Application preparation required to use the UBWCDMA Driver APIs</b>
</p><h4>
<a name="DMA%20Voting"></a>DMA Voting
</h4><p>
The developer should vote for the DMA according to the frequency plan as described in Figure 5. The voting sequence should be called after DMA engines are allocated in the <i>DMA Driver API flow</i>.
</p><left><img src="images/ubwcdma_voting.png"></left><p>
<b>Figure 5: Voting for the DMA based on the frequency plan</b>
</p><p>
For SM8150 and future targets, the DMA Voting is simplified by using the nDmaWrapper_PowerVoting() API as described in Figure 6.
</p><left><img src="images/ubwcdma_wrapper_voting.png"></left><p>
<b>Figure 6: Voting for the DMA using the simplied wrapper API</b>
</p><h2>
<a name="Developer%20Notes"></a><a name="developer_notes">Developer Notes</a>
</h2><p>
The following describes factors that DMA users should be aware of:
</p><ol type="1">
<li>
<p>
The DMA imposes some restrictions and considerations for efficient design as well as performance reasons:
</p><ol type="a">
<li>
<p>
The DMA cannot perform TCM to TCM transactions.
</p>
</li><li>
<p>
DMA engines should only be allocated entirely for reads (DDR to L2) or for writes (L2 to DDR). It is extremely inefficient to use a single engine to do both.
</p>
</li><li>
<p>
Linear reads and writes of small chunks of data is inefficient and should be avoided if possible. The hardware prefers reads and writes to be 256 byte aligned and the transaction size to be a multiple of 256 bytes. If this is not the case an extra read or write may be necessary. If the transactions are of large width then an extra read is inconsequential. However, reading one pixel at a time for example is detrimental to performance.
</p>
</li>
</ol>
</li><li>
<p>
Compilation options are specified in variants. More information about the variants and various possible Makefile options useful in development can be found in the <i>docs/Environments_Command Line.html</i> file provided with the SDK.
</p><ol type="a">
<li>
<p>
The firmware is precompiled for a specific set of variants. Not all variants are supported. Currently this only includes certain v65/v66 static library based release and debug variants. A full list of possible variants can be found in the <i>glue</i> directory shipped with each example. The list of variants supported by the firmware can be found in the <i>&lt;HEXAGON_SDK_ROOT&gt;/libs/ubwcdma/fw</i> directory.
</p>
</li><li>
<p>
In order to compile an example for one of the supported variants, do:
</p><ul type="circle">
<li>
<p>
<i>make V=&lt;VARIANT&gt; (eg: make V=hexagon_Debug_dynamic_toolv83_v65)</i>
</p>
</li>
</ul>
</li><li>
<p>
If an invalid variant is compiled (not accepted by the SDK), the user will see an error of the form:
</p><ul type="circle">
<li>
<p>
<i>&lt;Variant&gt; is not a supported build variant</i>
</p>
</li>
</ul>
</li><li>
<p>
DMA hardware is only available for v65 and v66 based chips and onwards.
</p>
</li><li>
<p>
Compilation of the examples will also cause a simulation to occur at the end of the compilation. This will occur whenever a file is modified. If the user wishes to run a simulation without compilation, the simulation output can be captured. Then the user should look for <i>hexagon-sim</i>. The line with that command is the command to run the simulation, copying the line and running it will cause a simulation to be launched without the need to recompile.
</p>
</li>
</ol>
</li><li>
<p>
The DMA examples are built on top of an operating system. Specifically, they are built on top of QURT. This is in order to enable the software to run on Hexagon hardware. The following provides some QURT related notes:
</p><ol type="a">
<li>
<p>
QURT has the ability to access the MMU and use virtual addresses. All applications must use virtual addresses to access the DDR and TCM. However, the DMA expects physical addresses and so addresses must be converted prior to providing them to the DMA. The exception is descriptor addresses which are also used by the firmware and should be virtual. Thus, data based addresses (DDR and TCM based buffers) must be physical while descriptor based addresses must be virtual. Virtual to physical address conversion can be accomplished by QURT methods (see the examples).
</p>
</li><li>
<p>
The regions provided to the DMA must be contiguous (both data based and descriptor based). For this reason, the use of malloc to set up buffers to be passed to the DMA is not permitted, as malloc may allocate contiguous virtual addresses which are non-contiguous in physical memory. The alternative is to use QURT to map regions which are guaranteed to be contiguous (see the examples). The use of malloc is still permitted for user structures and for data that the DMA will not access.
</p>
</li><li>
<p>
The user must allocate DDR regions to be used as TCM by locking regions using the CDSP L2 Cache Locking HAP Interface (HAP_cache_lock and HAP_cache_unlock API's). Currently in the examples the Cache Locking HAP Interface is not used when running on the simulator as it is not supported. The QURT locking functions are used instead when running on the simulators (please see dma_apps_sum_hvx_imp.c, dma_apps_blend_imp.c, and dma_apps_memcpy_imp.c). In general these regions should not be too large as there is only a maximum of 512k to use for the TCM currently and other apps may also be running.
</p>
</li><li>
<p>
QURT does not accept uninitialized pointers. An uninitialized pointer may corrupt the stack and lead to program crashes that are difficult to debug. The user should ensure all pointers that are declared are initialized immediately afterwards. This includes pointers that are present in structures.
</p>
</li><li>
<p>
printf may crash when used in QURT. The alternative is to use the function qurt_printf. However, this function is not able to display floating point numbers.
</p>
</li><li>
<p>
QURT addresses are always allocated in sizes of 4k and are aligned to 4k.
</p>
</li><li>
<p>
QURT uses memory pools to provide users with memory regions which can be used. The user indicates to QURT which pool is to be used. The pool structure on the SDK and on hardware have been found to vary.
</p>
</li>
</ol>
</li><li>
<p>
All code provided in the examples is able to run on hardware with the exception of the code guarded by the __hexagon__ macro in dma_apps_test.c. On hardware the dma_apps_test.c source is used as part of the Android side application. In the case of the Hexagon simulator, dma_apps_test.c is compiled as part of the application on the Hexagon side and the __hexagon__ macro is enabled and used to facilitate this.
</p><ol type="a">
<li>
<p>
When running on the simulator the __hexagon__ macro is enabled in dma_apps_test.c and illustrates the following:
</p><ul type="circle">
<li>
<p>
Frames in DDR to be transferred by the ubwcdma cosim must be mapped by QURT to guarantee a contigous region.
</p>
</li><li>
<p>
UBWC frames need to be 4k aligned, which by is handled by QURT during allocation.
</p>
</li><li>
<p>
The DMA registers must also be mapped to QURT memory pools on the simulator. This is done on a separate pool known as the DRIVER_POOL. These registers are a fixed communication point between the Cosim and the firmware and their address may not change. In order to achieve this a special kind of mapping which maps physical and virtual memory in a one to one mapping is used. This is done by calling a DMA initialization function. However, in order to ensure the chosen physical address is obtained by the DMA, the user must ensure that the DMA initialization functions are run first before using the DRIVER_POOL for any other process. This restriction is removed in hardware as these registers are mapped elsewhere.
</p>
</li><li>
<p>
The main application flow (test_main_start) is run as a thread with a suitable stack size as the main thread on the simulator does not provide a sufficient stack size during application execution.
</p>
</li>
</ul>
</li><li>
<p>
When running on the hardware the __hexagon__ macro is disabled in dma_apps_test.c and illustrates the following:
</p><ul type="circle">
<li>
<p>
Frames in DDR to be transferred by the ubwcdma hardware are ION buffers to guaratee a contiguous region (see rpcmem_android.c as included in the Hexagon SDK).
</p>
</li>
</ul>
</li>
</ol>
</li><li>
<p>
Note that buffers that have been compressed on the hexagon simulator cannot be used on target devices and vice versa. For example, if you dump a compressed buffer from memory to file on the hexagon simulator and use that file as an input on a target device you will encounter an error. Due to the nature of hexagon simulator COSIMS, we are unable to make compressed frames compatible cross platform. However, uncompressed buffers (linear formats) are compatible between the simulator and target devices.
</p>
</li><li>
<p>
On SDM845 targets the UBWCDMA firmware that is used is a legacy variant which does not support certain API's such as <i>nDmaWrapper_PowerVoting</i>. In order to use the correct headers and firmware libraries on SDM845 targets please run the make command with the additional flag <b>UBWCDMA_LEGACY_DRIVER=1</b>. This will point the make.d build system to the correct directories. Please see $(HEXAGON_SDK_ROOT)/libs/ubwcdma/ubwcdma.min for specific details.
</p>
</li>
</ol><p align="center" style="display:block;padding-top: 50px;">
  Copyright &#169; 2018 Qualcomm Technologies Inc. All rights reserved.

</p><a style="display:block;padding-bottom: 700px;"></a></div></div>
</body>
</html>
